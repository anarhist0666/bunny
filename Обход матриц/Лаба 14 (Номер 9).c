/*
 * ============================================================================
 *                         ТЕОРИЯ: МАССИВЫ В ЯЗЫКЕ C
 * ============================================================================
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                        1. ОДНОМЕРНЫЕ МАССИВЫ                            │
 * └─────────────────────────────────────────────────────────────────────────┘
 *
 * Одномерный массив — это последовательность элементов одного типа,
 * расположенных в памяти друг за другом.
 *
 * ОБЪЯВЛЕНИЕ:
 *   тип имя[размер];
 *
 * ПРИМЕРЫ:
 *   int numbers[5];           // Массив из 5 целых чисел
 *   double prices[100];       // Массив из 100 вещественных чисел
 *   char name[50];            // Массив из 50 символов (строка)
 *
 * ИНИЦИАЛИЗАЦИЯ:
 *   int arr[5] = {1, 2, 3, 4, 5};     // Полная инициализация
 *   int arr[5] = {1, 2};              // Частичная (остальные = 0)
 *   int arr[] = {1, 2, 3};            // Размер определяется автоматически (3)
 *   int arr[5] = {0};                 // Все элементы = 0
 *
 * ИНДЕКСАЦИЯ:
 *   arr[0] — первый элемент
 *   arr[4] — пятый (последний) элемент массива размера 5
 *
 * ПАМЯТЬ (для int arr[5]):
 *   ┌───────┬───────┬───────┬───────┬───────┐
 *   │ arr[0]│ arr[1]│ arr[2]│ arr[3]│ arr[4]│
 *   └───────┴───────┴───────┴───────┴───────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                        2. ДВУМЕРНЫЕ МАССИВЫ                             │
 * └─────────────────────────────────────────────────────────────────────────┘
 *
 * Двумерный массив — это "массив массивов", представляющий таблицу
 * с строками и столбцами.
 *
 * ОБЪЯВЛЕНИЕ:
 *   тип имя[строки][столбцы];
 *
 * ПРИМЕРЫ:
 *   int matrix[3][4];         // Матрица 3 строки × 4 столбца
 *   double table[10][10];     // Таблица 10×10
 *
 * ИНИЦИАЛИЗАЦИЯ:
 *   int m[2][3] = {           // 2 строки, 3 столбца
 *       {1, 2, 3},            // Строка 0
 *       {4, 5, 6}             // Строка 1
 *   };
 *
 *   int m[2][3] = {1,2,3,4,5,6};  // То же самое, построчно
 *
 * ВИЗУАЛИЗАЦИЯ (matrix[3][4]):
 *
 *              столбец 0   столбец 1   столбец 2   столбец 3
 *            ┌───────────┬───────────┬───────────┬───────────┐
 *   строка 0 │  [0][0]   │  [0][1]   │  [0][2]   │  [0][3]   │
 *            ├───────────┼───────────┼───────────┼───────────┤
 *   строка 1 │  [1][0]   │  [1][1]   │  [1][2]   │  [1][3]   │
 *            ├───────────┼───────────┼───────────┼───────────┤
 *   строка 2 │  [2][0]   │  [2][1]   │  [2][2]   │  [2][3]   │
 *            └───────────┴───────────┴───────────┴───────────┘
 *
 * ХРАНЕНИЕ В ПАМЯТИ (построчно / row-major order):
 *   [0][0] → [0][1] → [0][2] → [0][3] → [1][0] → [1][1] → ...
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                    3. SCANF И МАССИВЫ                                   │
 * └─────────────────────────────────────────────────────────────────────────┘
 *
 * scanf() требует АДРЕС переменной для записи значения.
 * Оператор & возвращает адрес переменной.
 *
 * ДЛЯ ОБЫЧНОЙ ПЕРЕМЕННОЙ:
 *   int x;
 *   scanf("%d", &x);          // &x — адрес переменной x
 *
 * ДЛЯ ЭЛЕМЕНТА МАССИВА:
 *   int arr[5];
 *   scanf("%d", &arr[2]);     // &arr[2] — адрес третьего элемента
 *
 * ДЛЯ ДВУМЕРНОГО МАССИВА:
 *   int matrix[3][3];
 *   scanf("%d", &matrix[1][2]);  // &matrix[1][2] — адрес элемента
 *
 * ЗАПОЛНЕНИЕ ОДНОМЕРНОГО МАССИВА:
 *   int arr[5];
 *   for (int i = 0; i < 5; i++) {
 *       scanf("%d", &arr[i]);
 *   }
 *
 * ЗАПОЛНЕНИЕ ДВУМЕРНОГО МАССИВА:
 *   int matrix[3][4];
 *   for (int row = 0; row < 3; row++) {         // Перебор строк
 *       for (int col = 0; col < 4; col++) {     // Перебор столбцов
 *           scanf("%d", &matrix[row][col]);
 *       }
 *   }
 *
 * ВАЖНО: Имя массива БЕЗ индекса — это уже адрес первого элемента:
 *   arr    эквивалентно  &arr[0]
 *   arr+2  эквивалентно  &arr[2]
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │              4. VLA — МАССИВЫ ПЕРЕМЕННОЙ ДЛИНЫ                          │
 * └─────────────────────────────────────────────────────────────────────────┘
 *
 * VLA (Variable Length Array) — массив, размер которого определяется
 * во время выполнения программы, а не на этапе компиляции.
 *
 * СТАНДАРТНЫЙ МАССИВ (размер известен при компиляции):
 *   int arr[100];             // Размер 100 — константа
 *   #define SIZE 50
 *   int arr[SIZE];            // SIZE — макрос, известен при компиляции
 *
 * VLA (размер определяется во время выполнения):
 *   int n;
 *   scanf("%d", &n);          // n вводится пользователем
 *   int arr[n];               // VLA: размер определяется значением n
 *   int matrix[n][n];         // VLA: двумерный массив n×n
 *
 * ОГРАНИЧЕНИЯ:
 *   • Нельзя инициализировать при объявлении:
 *          int n = 5;
 *          int arr[n] = {1, 2, 3};    // ОШИБКА!
 *          int arr[n];                 // OK
 *          arr[0] = 1; arr[1] = 2;    // Заполнять поэлементно
 *
 *   • Нельзя объявлять как глобальные или static:
 *          static int arr[n];          // ОШИБКА!
 *
 *   • Размер стека ограничен (обычно 1-8 МБ):
 *          int huge[1000000];          // Может вызвать переполнение стека!
 *
 * ПРИМЕРЫ:
 *
 *   // Одномерный VLA
 *   int size;
 *   scanf("%d", &size);
 *   int numbers[size];
 *   for (int i = 0; i < size; i++) {
 *       scanf("%d", &numbers[i]);
 *   }
 *
 *   // Двумерный VLA (матрица произвольного размера)
 *   int rows, cols;
 *   scanf("%d %d", &rows, &cols);
 *   int matrix[rows][cols];
 *   for (int i = 0; i < rows; i++) {
 *       for (int j = 0; j < cols; j++) {
 *           scanf("%d", &matrix[i][j]);
 *       }
 *   }
 *
 *   // VLA в параметрах функции (C99+)
 *   void printMatrix(int rows, int cols, int matrix[rows][cols]) {
 *       for (int i = 0; i < rows; i++) {
 *           for (int j = 0; j < cols; j++) {
 *               printf("%d ", matrix[i][j]);
 *           }
 *           printf("\n");
 *       }
 *   }
 *
 * ============================================================================
 */

 
#include <stdio.h>

int main(void) {
    /* ─────────────────────────────────────────────────────────────────────
     * ЭТАП 1: Чтение размера матрицы
     * ───────────────────────────────────────────────────────────────────── */
    int size;
    scanf("%d", &size);

    /* ─────────────────────────────────────────────────────────────────────
     * ЭТАП 2: Создание и заполнение квадратной матрицы
     * 
     * Здесь используется VLA (Variable Length Array) — массив переменной
     * длины. Размер size известен только во время выполнения программы,
     * после того как пользователь введёт значение.
     * 
     * VLA размещается в стеке и автоматически освобождается при выходе
     * из функции main(). Это удобно для небольших матриц.
     * 
     * Порядок заполнения матрицы 4×4:
     * 
     *     col=0   col=1   col=2   col=3
     *   ┌───────┬───────┬───────┬───────┐
     *   │  1→   │  2→   │  3→   │  4    │  row=0 (сначала вся строка 0)
     *   ├───────┼───────┼───────┼───────┤
     *   │  5→   │  6→   │  7→   │  8    │  row=1 (затем вся строка 1)
     *   ├───────┼───────┼───────┼───────┤
     *   │  9→   │ 10→   │ 11→   │ 12    │  row=2 (затем вся строка 2)
     *   ├───────┼───────┼───────┼───────┤
     *   │ 13→   │ 14→   │ 15→   │ 16    │  row=3 (наконец вся строка 3)
     *   └───────┴───────┴───────┴───────┘
     * ───────────────────────────────────────────────────────────────────── */
    int array[size][size];  /* VLA: двумерный массив size×size */
    
    /* Построчное чтение матрицы: сначала все элементы строки 0,
     * затем все элементы строки 1, и так далее */
    for (int row = 0; row < size; row++) {
        for (int col = 0; col < size; col++) {
            scanf("%d", &array[row][col]);
        }
    }

    /* ─────────────────────────────────────────────────────────────────────
     * ЭТАП 3: Обход матрицы по диагоналям "змейкой"
     * 
     * Всего диагоналей: (size * 2 - 1)
     * 
     * ФОРМУЛА: totalDiagonals = size * 2 - 1
     * ПОЯСНЕНИЕ:
     *   - В квадратной матрице size×size есть:
     *     • size диагоналей в нижней части (включая главную)
     *     • size-1 диагоналей в верхней части
     *   - Итого: size + (size - 1) = size * 2 - 1
     * 
     * Для матрицы 4×4: 4*2 - 1 = 7 диагоналей (индексы от 0 до 6)
     * 
     * Схема всех диагоналей (цифра = номер диагонали):
     * 
     *     col=0   col=1   col=2   col=3
     *   ┌───────┬───────┬───────┬───────┐
     *   │   3   │   4   │   5   │   6   │  row=0
     *   ├───────┼───────┼───────┼───────┤
     *   │   2   │   3   │   4   │   5   │  row=1
     *   ├───────┼───────┼───────┼───────┤
     *   │   1   │   2   │   3   │   4   │  row=2
     *   ├───────┼───────┼───────┼───────┤
     *   │   0   │   1   │   2   │   3   │  row=3
     *   └───────┴───────┴───────┴───────┘
     * 
     * Каждая диагональ идёт из нижнего-левого в верхний-правый:
     *   row уменьшается (↑), col увеличивается (→)
     * ───────────────────────────────────────────────────────────────────── */
    for (int diagonal = 0; diagonal < (size * 2 - 1); diagonal++) {
        
        /* ─────────────────────────────────────────────────────────────────
         * ЭТАП 3.1: Определение начальной точки диагонали
         * 
         * Диагонали делятся на две группы:
         * 
         * ГРУППА 1: diagonal < size (диагонали 0, 1, 2, 3 для size=4)
         *   Начинаются на левом краю матрицы (col = 0)
         *   
         *     col=0   col=1   col=2   col=3
         *   ┌───────┬───────┬───────┬───────┐
         *   │       │       │       │       │  
         *   ├───────┼───────┼───────┼───────┤
         *   │       │       │       │       │  
         *   ├───────┼───────┼───────┼───────┤
         *   │  d=1  │       │       │       │  ← диаг.1 начинается в [2][0]
         *   ├───────┼───────┼───────┼───────┤
         *   │  d=0  │       │       │       │  ← диаг.0 начинается в [3][0]
         *   └───────┴───────┴───────┴───────┘
         *   
         *   ФОРМУЛА: firstRow = size - diagonal - 1
         *   ПОЯСНЕНИЕ:
         *     - Стартуем с нижней строки (size-1)
         *     - С каждой следующей диагональю поднимаемся на 1 строку вверх
         *     - diagonal=0: size-0-1 = 3 (нижняя строка)
         *     - diagonal=1: size-1-1 = 2 (на строку выше)
         *     - diagonal=2: size-2-1 = 1 (ещё выше)
         *     - diagonal=3: size-3-1 = 0 (верхняя строка)
         *   
         *   diagonal=0: firstRow = 4-0-1 = 3  → [3][0]
         *   diagonal=1: firstRow = 4-1-1 = 2  → [2][0]
         *   diagonal=2: firstRow = 4-2-1 = 1  → [1][0]
         *   diagonal=3: firstRow = 4-3-1 = 0  → [0][0]
         * 
         * ГРУППА 2: diagonal >= size (диагонали 4, 5, 6 для size=4)
         *   Начинаются на верхнем краю матрицы (row = 0)
         *   
         *     col=0   col=1   col=2   col=3
         *   ┌───────┬───────┬───────┬───────┐
         *   │       │  d=4  │  d=5  │  d=6  │  ← диагонали начинаются сверху
         *   ├───────┼───────┼───────┼───────┤
         *   │       │       │       │       │  
         *   ├───────┼───────┼───────┼───────┤
         *   │       │       │       │       │  
         *   ├───────┼───────┼───────┼───────┤
         *   │       │       │       │       │  
         *   └───────┴───────┴───────┴───────┘
         *   
         *   ФОРМУЛА: firstCol = diagonal - size + 1
         *   ПОЯСНЕНИЕ:
         *     - После достижения верхнего края (diagonal=size-1, col=0),
         *       дальше двигаемся вправо вдоль верхней строки
         *     - diagonal=size: мы "прошли" size диагоналей, значит 
         *       сдвигаемся на 1 столбец вправо: size-size+1 = 1
         *     - С каждой следующей диагональю сдвигаемся ещё правее
         *   
         *   diagonal=4: firstCol = 4-4+1 = 1  → [0][1]
         *   diagonal=5: firstCol = 5-4+1 = 2  → [0][2]
         *   diagonal=6: firstCol = 6-4+1 = 3  → [0][3]
         *   
         *   Альтернативное объяснение:
         *     - diagonal-size показывает, сколько диагоналей прошли 
         *       после главной (diagonal=size-1)
         *     - +1 потому что после главной диагонали (где col=0) 
         *       следующая начинается с col=1
         * ───────────────────────────────────────────────────────────────── */
        int firstRow, firstCol;

        if (diagonal >= size) {
            /* Верхняя часть: диагонали начинаются с верхней строки */
            firstRow = 0;
            firstCol = diagonal - size + 1;
        } else {
            /* Нижняя часть: диагонали начинаются с левого столбца */
            firstRow = size - diagonal - 1;
            firstCol = 0;
        }

        /* ─────────────────────────────────────────────────────────────────
         * ЭТАП 3.2: Вычисление длины текущей диагонали
         * 
         * Длина диагоналей образует "пирамиду":
         *   - Сначала растёт от 1 до size
         *   - Затем уменьшается от size до 1
         * 
         * Для size=4:
         *   diagonal: 0  1  2  3  4  5  6
         *   length:   1  2  3  4  3  2  1
         * 
         * Визуализация длин диагоналей:
         * 
         *     col=0   col=1   col=2   col=3
         *   ┌───────┬───────┬───────┬───────┐
         *   │ len=4 │ len=3 │ len=2 │ len=1 │  
         *   ├───────┼───────┼───────┼───────┤
         *   │ len=3 │ len=4 │ len=3 │ len=2 │  
         *   ├───────┼───────┼───────┼───────┤
         *   │ len=2 │ len=3 │ len=4 │ len=3 │  
         *   ├───────┼───────┼───────┼───────┤
         *   │ len=1 │ len=2 │ len=3 │ len=4 │  
         *   └───────┴───────┴───────┴───────┘
         *     d=0     d=1     d=2     d=3   (начальные точки диагоналей)
         * 
         * diagonal < size:     length = diagonal + 1
         *   ПОЯСНЕНИЕ: длина растёт с каждой диагональю
         *   - diagonal=0: length = 0+1 = 1 элемент
         *   - diagonal=1: length = 1+1 = 2 элемента
         *   - diagonal=2: length = 2+1 = 3 элемента
         *   - diagonal=3: length = 3+1 = 4 элемента (главная диагональ)
         * 
         * diagonal >= size:    length = (size * 2 - 1) - diagonal
         *   ФОРМУЛА РАСШИФРОВКА:
         *     (size * 2 - 1) — это индекс последней диагонали
         *     (size * 2 - 1) - diagonal — расстояние от текущей до последней
         *   
         *   ПОЯСНЕНИЕ: длина уменьшается симметрично
         *   - Последняя диагональ имеет длину 1
         *   - Предпоследняя — длину 2, и т.д.
         *   
         *   Для size=4 (последняя диагональ = 6):
         *   - diagonal=4: length = 7-4 = 3 элемента
         *   - diagonal=5: length = 7-5 = 2 элемента
         *   - diagonal=6: length = 7-6 = 1 элемент
         *   
         *   Альтернативное объяснение:
         *   - diagonal=4 это первая диагональ после главной (3)
         *   - она "зеркальна" diagonal=2 (которая имеет length=3)
         *   - diagonal=5 зеркальна diagonal=1 (length=2)
         *   - diagonal=6 зеркальна diagonal=0 (length=1)
         * ───────────────────────────────────────────────────────────────── */
        int diagonalLength;
        if (diagonal >= size) {
            /* Убывающая часть: от главной диагонали к правому верхнему углу */
            diagonalLength = (size * 2 - 1) - diagonal;
        } else {
            /* Возрастающая часть: от левого нижнего угла к главной диагонали */
            diagonalLength = diagonal + 1;
        }

        /* ─────────────────────────────────────────────────────────────────
         * ЭТАП 3.3: Обход диагонали с чередованием направления
         * 
         * Эффект "змейки" достигается чередованием направления обхода:
         *   - Чётные диагонали (0, 2, 4, 6): ОБРАТНЫЙ порядок ↙
         *   - Нечётные диагонали (1, 3, 5): ПРЯМОЙ порядок ↗
         * 
         * Визуализация змейки на матрице со значениями:
         * 
         *     col=0   col=1   col=2   col=3
         *   ┌───────┬───────┬───────┬───────┐
         *   │   1   │   2   │   3   │   4   │  row=0
         *   ├───────┼───────┼───────┼───────┤
         *   │   5   │   6   │   7   │   8   │  row=1
         *   ├───────┼───────┼───────┼───────┤
         *   │   9   │  10   │  11   │  12   │  row=2
         *   ├───────┼───────┼───────┼───────┤
         *   │  13   │  14   │  15   │  16   │  row=3
         *   └───────┴───────┴───────┴───────┘
         * 
         * d=0 (чёт, ↙): 13
         *     ┌───┬───┬───┬───┐
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │[●]│   │   │   │  ← выводим: 13
         *     └───┴───┴───┴───┘
         * 
         * d=1 (нечёт, ↗): 9 → 14
         *     ┌───┬───┬───┬───┐
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │[1]│   │   │   │  ← начинаем здесь (9)
         *     ├───┼───┼───┼───┤
         *     │   │[2]│   │   │  ← заканчиваем здесь (14)
         *     └───┴───┴───┴───┘
         *     Выводим: 9, 14
         * 
         * d=2 (чёт, ↙): 15 → 10 → 5
         *     ┌───┬───┬───┬───┐
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │[3]│   │   │   │  ← заканчиваем здесь (5)
         *     ├───┼───┼───┼───┤
         *     │   │[2]│   │   │  ← затем сюда (10)
         *     ├───┼───┼───┼───┤
         *     │   │   │[1]│   │  ← начинаем здесь (15)
         *     └───┴───┴───┴───┘
         *     Выводим: 15, 10, 5
         * 
         * d=3 (нечёт, ↗): 1 → 6 → 11 → 16 (главная диагональ)
         *     ┌───┬───┬───┬───┐
         *     │[1]│   │   │   │  ← начинаем здесь (1)
         *     ├───┼───┼───┼───┤
         *     │   │[2]│   │   │  ← затем сюда (6)
         *     ├───┼───┼───┼───┤
         *     │   │   │[3]│   │  ← затем сюда (11)
         *     ├───┼───┼───┼───┤
         *     │   │   │   │[4]│  ← заканчиваем здесь (16)
         *     └───┴───┴───┴───┘
         *     Выводим: 1, 6, 11, 16
         * 
         * d=4 (чёт, ↙): 12 → 7 → 2
         *     ┌───┬───┬───┬───┐
         *     │   │[3]│   │   │  ← заканчиваем здесь (2)
         *     ├───┼───┼───┼───┤
         *     │   │   │[2]│   │  ← затем сюда (7)
         *     ├───┼───┼───┼───┤
         *     │   │   │   │[1]│  ← начинаем здесь (12)
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     └───┴───┴───┴───┘
         *     Выводим: 12, 7, 2
         * 
         * d=5 (нечёт, ↗): 3 → 8
         *     ┌───┬───┬───┬───┐
         *     │   │   │[1]│   │  ← начинаем здесь (3)
         *     ├───┼───┼───┼───┤
         *     │   │   │   │[2]│  ← заканчиваем здесь (8)
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     └───┴───┴───┴───┘
         *     Выводим: 3, 8
         * 
         * d=6 (чёт, ↙): 4
         *     ┌───┬───┬───┬───┐
         *     │   │   │   │[●]│  ← выводим: 4
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     ├───┼───┼───┼───┤
         *     │   │   │   │   │
         *     └───┴───┴───┴───┘
         * 
         * ИТОГО: 13 9 14 15 10 5 1 6 11 16 12 7 2 3 8 4
         * ───────────────────────────────────────────────────────────────── */
        if (diagonal % 2 == 0) {
            /* ─────────────────────────────────────────────────────────────
             * ЧЁТНАЯ ДИАГОНАЛЬ: обратный обход (от конца к началу) ↙
             * 
             * step идёт от (diagonalLength - 1) до 0
             * Это даёт нам элементы от дальнего конца диагонали к началу
             * 
             * Пример: диагональ 2, length=3, начало в [1][0]
             * 
             *   Элементы диагонали:
             *     step=0: [1][0] = 5   (начальная точка)
             *     step=1: [2][1] = 10
             *     step=2: [3][2] = 15  (конечная точка)
             *   
             *   Обратный обход (step от 2 до 0):
             *     step=2: [1+2][0+2] = [3][2] = 15  ← выводим первым
             *     step=1: [1+1][0+1] = [2][1] = 10  ← выводим вторым
             *     step=0: [1+0][0+0] = [1][0] = 5   ← выводим третьим
             *   
             *   Результат: 15, 10, 5
             *   
             * ФОРМУЛА: array[firstRow + step][firstCol + step]
             * ПОЯСНЕНИЕ ИНДЕКСАЦИИ:
             *   - firstRow, firstCol — стартовая точка диагонали
             *   - step — шаг вдоль диагонали (0, 1, 2, ...)
             *   - При движении по диагонали ↗:
             *     • row увеличивается на 1 → firstRow + step
             *     • col увеличивается на 1 → firstCol + step
             *   - Оба индекса меняются одинаково, потому что диагональ
             *     идёт под углом 45° (на 1 клетку вправо и на 1 вниз/вверх)
             *   
             * Детальный пример для diagonal=2:
             *   firstRow=1, firstCol=0, length=3
             *   
             *   step=0: array[1+0][0+0] = array[1][0]
             *           ↑row не меняется  ↑col не меняется
             *   
             *   step=1: array[1+1][0+1] = array[2][1]
             *           ↑row+1 (вниз)     ↑col+1 (вправо)
             *   
             *   step=2: array[1+2][0+2] = array[3][2]
             *           ↑row+2 (ещё вниз) ↑col+2 (ещё вправо)
             * ───────────────────────────────────────────────────────────── */
            for (int step = diagonalLength - 1; step >= 0; step--) {
                printf("%d ", array[firstRow + step][firstCol + step]);
            }
        } else {
            /* ─────────────────────────────────────────────────────────────
             * НЕЧЁТНАЯ ДИАГОНАЛЬ: прямой обход (от начала к концу) ↗
             * 
             * step идёт от 0 до (diagonalLength - 1)
             * Это даёт нам элементы от начала диагонали к дальнему концу
             * 
             * Пример: диагональ 3 (главная), length=4, начало в [0][0]
             * 
             *   Прямой обход (step от 0 до 3):
             *     step=0: [0+0][0+0] = [0][0] = 1   ← выводим первым
             *     step=1: [0+1][0+1] = [1][1] = 6   ← выводим вторым
             *     step=2: [0+2][0+2] = [2][2] = 11  ← выводим третьим
             *     step=3: [0+3][0+3] = [3][3] = 16  ← выводим четвёртым
             *   
             *   Результат: 1, 6, 11, 16
             *   
             * ФОРМУЛА: array[firstRow + step][firstCol + step]
             * ПОЯСНЕНИЕ (аналогично чётным диагоналям):
             *   - step добавляется к обоим индексам
             *   - Это смещает нас вдоль диагонали на step позиций
             *   - Каждый шаг: на 1 клетку вниз И на 1 клетку вправо
             *   
             * Визуализация движения для diagonal=3:
             *   
             *   step=0:        step=1:        step=2:        step=3:
             *   ┌─┬─┬─┬─┐      ┌─┬─┬─┬─┐      ┌─┬─┬─┬─┐      ┌─┬─┬─┬─┐
             *   │●│ │ │ │      │ │ │ │ │      │ │ │ │ │      │ │ │ │ │
             *   ├─┼─┼─┼─┤      ├─┼─┼─┼─┤      ├─┼─┼─┼─┤      ├─┼─┼─┼─┤
             *   │ │ │ │ │      │ │●│ │ │      │ │ │ │ │      │ │ │ │ │
             *   ├─┼─┼─┼─┤      ├─┼─┼─┼─┤      ├─┼─┼─┼─┤      ├─┼─┼─┼─┤
             *   │ │ │ │ │      │ │ │ │ │      │ │ │●│ │      │ │ │ │ │
             *   ├─┼─┼─┼─┤      ├─┼─┼─┼─┤      ├─┼─┼─┼─┤      ├─┼─┼─┼─┤
             *   │ │ │ │ │      │ │ │ │ │      │ │ │ │ │      │ │ │ │●│
             *   └─┴─┴─┴─┘      └─┴─┴─┴─┘      └─┴─┴─┴─┘      └─┴─┴─┴─┘
             *   [0][0]         [1][1]         [2][2]         [3][3]
             *   +0 +0          +1 +1          +2 +2          +3 +3
             * ───────────────────────────────────────────────────────────── */
            for (int step = 0; step < diagonalLength; step++) {
                printf("%d ", array[firstRow + step][firstCol + step]);
            }
        }
    }
    
    return 0;
}

/*
 * ============================================================================
 *                          ПРИМЕР РАБОТЫ ПРОГРАММЫ
 * ============================================================================
 *
 * Входные данные:
 * 4
 * 1  2  3  4
 * 5  6  7  8
 * 9  10 11 12
 * 13 14 15 16
 *
 * Матрица в памяти:
 *            col=0   col=1   col=2   col=3
 *         ┌───────┬───────┬───────┬───────┐
 * row=0   │   1   │   2   │   3   │   4   │
 *         ├───────┼───────┼───────┼───────┤
 * row=1   │   5   │   6   │   7   │   8   │
 *         ├───────┼───────┼───────┼───────┤
 * row=2   │   9   │  10   │  11   │  12   │
 *         ├───────┼───────┼───────┼───────┤
 * row=3   │  13   │  14   │  15   │  16   │
 *         └───────┴───────┴───────┴───────┘
 *
 * Обход по диагоналям:
 *
 * Диагональ 0 (чётная, обратный): [3][0] = 13
 * Диагональ 1 (нечётная, прямой): [2][0]=9, [3][1]=14
 * Диагональ 2 (чётная, обратный): [3][2]=15, [2][1]=10, [1][0]=5
 * Диагональ 3 (нечётная, прямой): [0][0]=1, [1][1]=6, [2][2]=11, [3][3]=16
 * Диагональ 4 (чётная, обратный): [2][3]=12, [1][2]=7, [0][1]=2
 * Диагональ 5 (нечётная, прямой): [0][2]=3, [1][3]=8
 * Диагональ 6 (чётная, обратный): [0][3] = 4
 *
 * Вывод: 13 9 14 15 10 5 1 6 11 16 12 7 2 3 8 4
 *
 * ============================================================================
 */