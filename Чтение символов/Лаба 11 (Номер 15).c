/*
 * ============================================================================
 *
 * 1. ЦИКЛ `while` - ЦИКЛ С ПРЕДУСЛОВИЕМ
 *    Цикл `while` выполняет блок кода ПОКА условие истинно.
 *    Используется, когда количество итераций неизвестно заранее.
 *
 *    Синтаксис:
 *        while (условие) {
 *            // тело цикла
 *        }
 *
 *    Особенность: если условие ложно с самого начала, тело цикла не выполнится ни разу.
 *
 * ============================================================================
 *
 * 2. ФУНКЦИЯ `getchar()` И ЧТЕНИЕ ВВОДА
 *    Функция `getchar()` из библиотеки <stdio.h> читает ОДИН СИМВОЛ из стандартного
 *    входного потока (обычно с клавиатуры или из файла).
 *
 *    Важные характеристики:
 *    - Возвращает тип `int`, а не `char`
 *    - Возвращает ASCII-код прочитанного символа (0-255 для обычных символов)
 *    - При достижении конца ввода возвращает специальную константу EOF
 *    - Ввод буферизирован: символы отправляются в программу только после нажатия Enter
 *
 *    Почему `int`, а не `char`?
 *    Тип `char` может быть знаковым (-128..127) или беззнаковым (0..255).
 *    Значение EOF обычно равно -1, которое не помещается в беззнаковый char.
 *    Использование `int` гарантирует, что мы можем отличить любой символ от EOF.
 *
 * ============================================================================
 *
 * 3. КОНСТАНТА EOF (End Of File - Конец Файла)
 *    EOF - это макрос, определённый в <stdio.h>, который обозначает конец входного потока.
 *
 *    Ключевые моменты:
 *    - Значение обычно равно -1, но всегда используйте имя EOF, а не конкретное число
 *    - Сигнализирует о завершении ввода
 *    - Для клавиатурного ввода EOF передаётся комбинациями клавиш:
 *        Linux/macOS: Ctrl + D
 *        Windows:     Ctrl + Z, затем Enter
 *
 * 4. УПРАВЛЯЮЩИЕ СИМВОЛЫ (Escape Sequences)
 *    Управляющие символы - это специальные последовательности, начинающиеся с
 *    обратной косой черты `\`, которые представляют непечатаемые или специальные символы.
 *
 *    В данном коде используются:
 *        '\n' - новая строка (newline, LF - Line Feed)
 *        '\t' - табуляция (horizontal tab)
 *
 *    Другие распространённые управляющие символы:
 *        '\\' - обратная косая черта (поскольку одиночная `\` - специальный символ)
 *        '\"' - двойная кавычка
 *        '\'' - одинарная кавычка
 *        '\0' - нулевой символ (конец строки в C)
 *
 * ============================================================================
 *
 * 5. ПЕРЕМЕННЫЕ-ФЛАГИ (ФЛАГИ СОСТОЯНИЯ)
 *    Флаг - это переменная, которая хранит информацию о состоянии программы.
 *    Обычно используется для отслеживания условий или режимов работы.
 *
 *    Общепринятые соглашения:
 *        - 0 (ноль)      -> состояние "ЛОЖЬ", "НЕТ", "ВЫКЛЮЧЕНО", "НЕ АКТИВНО"
 *        - 1 (или любое ненулевое) -> состояние "ИСТИНА", "ДА", "ВКЛЮЧЕНО", "АКТИВНО"
 *
 * ============================================================================
 *
 * 6. ПРЕОБРАЗОВАНИЕ СИМВОЛА-ЦИФРЫ В ЧИСЛОВОЕ ЗНАЧЕНИЕ
 *    Символы цифр в ASCII таблице имеют последовательные коды:
 *        '0' -> код 48
 *        '1' -> код 49
 *        ...
 *        '9' -> код 57
 *
 *    Чтобы получить числовое значение цифры (0-9) из символа:
 *        char digit_char = '7';        // код 55
 *        int digit_value = digit_char - '0';  // 55 - 48 = 7
 *
 *    Это работает, потому что:
 *        '1' - '0' = 49 - 48 = 1
 *        '5' - '0' = 53 - 48 = 5
 *        '9' - '0' = 57 - 48 = 9
 *
 * ============================================================================
 *
 * 7. СРАВНЕНИЕ СИМВОЛОВ ЧЕРЕЗ ИХ ASCII-КОДЫ
 *    Поскольку символы хранятся как числа, их можно сравнивать с помощью операторов
 *    сравнения (<, <=, >, >=).
 *
 *    Проверка, является ли символ цифрой:
 *        if (symbol >= '0' && symbol <= '9')
 *
 *    Это эквивалентно:
 *        if (symbol >= 48 && symbol <= 57)
 *
 *    ASCII-свойства, используемые в коде:
 *        - Цифры '0'-'9' идут последовательно (коды 48-57)
 *        - Прописные буквы 'A'-'Z' идут последовательно (65-90)
 *        - Строчные буквы 'a'-'z' идут последовательно (97-122)
 *
 *    ВАЖНО: Это работает ТОЛЬКО для ASCII. Для других кодировок могут потребоваться
 *           специальные функции из библиотеки <ctype.h>:
 *
 *           #include <ctype.h>
 *
 *           Основные функции классификации символов:
 *           - int isalnum(int c)  - буква ИЛИ цифра (a-z, A-Z, 0-9)
 *           - int isalpha(int c)  - буква (a-z, A-Z)
 *           - int iscntrl(int c)  - управляющий символ
 *           - int isdigit(int c)  - десятичная цифра (0-9)
 *           - int isgraph(int c)  - печатаемый символ, кроме пробела
 *           - int islower(int c)  - строчная буква (a-z)
 *           - int isprint(int c)  - печатаемый символ (включая пробел)
 *           - int ispunct(int c)  - знак пунктуации (не буква, не цифра, не пробел)
 *           - int isspace(int c)  - пробельный символ (пробел, \t, \n, \r, \v, \f)
 *           - int isupper(int c)  - прописная буква (A-Z)
 *           - int isxdigit(int c) - шестнадцатеричная цифра (0-9, a-f, A-F)
 *
 *           Функции преобразования регистра:
 *           - int tolower(int c)  - преобразует в нижний регистр
 *           - int toupper(int c)  - преобразует в верхний регистр
 *
 *           Преимущества использования <ctype.h>:
 *           - Переносимость между разными кодировками и локалями
 *           - Читаемость кода
 *           - Работа с локалью (setlocale())
 *
 *           Пример использования вместо сравнения с ASCII:
 *           if (isdigit(symbol)) {          // вместо: if (symbol >= '0' && symbol <= '9')
 *               sum += symbol - '0';
 *           } else if (isspace(symbol)) {   // вместо: if (symbol == ' ' || symbol == '\t' || ...)
 *               // обработка пробела
 *           }
 *
 * ============================================================================
 *
 * 8. ОБРАБОТКА ПОСЛЕДНЕГО СЛОВА ПЕРЕД EOF
 *    Особенность потока ввода: когда достигается EOF, программа завершает цикл while,
 *    но последнее слово может не иметь разделителя после себя.
 *
 *    Решение: после цикла while проверяем, не остались ли мы внутри слова
 *    (flag == 1), и если да - выводим его сумму.
 *
 *    Без этой проверки последнее слово в тексте будет потеряно, если после него
 *    нет разделителя (пробела, запятой или новой строки).
 *
 * ============================================================================
 */

#include <stdio.h>


// Условие: Подсчитать контрольные суммы всех сло исходного текста


/*
 * Программа для подсчета контрольных сумм "слов" (слов/чисел) входного текста.
 * 
 * Логика работы:
 * 1. Чтение символов из стандартного ввода до конца потока (EOF).
 * 2. Разбиение текста на слова/числа по разделителям:
 *    - пробел (' ')
 *    - табуляция ('\t')
 *    - запятая (',')
 *    - перенос строки ('\n')
 * 3. Для каждого слова/числа вычисляется контрольная сумма:
 *    - Цифры ('0'-'9') учитываются как их числовое значение
 *    - Все остальные символы учитываются как их ASCII-код
 * 4. Результат: для каждого найденного слова/числа выводится его сумма в отдельной строке.
 * 
 * Пример работы:
 * Ввод:  "abc 123,test!"
 * Вывод: 294   (сумма 'abc': 97+98+99)
 *        6     (сумма '123': 1+2+3)
 *        528   (сумма 'test!': 116+101+115+116+33)
 */

int main() {
    int symbol;     // Текущий прочитанный символ (int для корректной обработки EOF)
    int sum = 0;    // Накопительная сумма символов текущего слова/числа
    int flag = 0;   /* Флаг наличия непробельных символов в текущем слове/числе:
                     * 0 - слово пусто или только что завершено
                     * 1 - в слове есть хотя бы один непробельный символ */
    
    /* Чтение входного потока посимвольно до конца файла */
    while ((symbol = getchar()) != EOF) {
        
        /* ПРОВЕРКА: ЯВЛЯЕТСЯ ЛИ СИМВОЛ РАЗДЕЛИТЕЛЕМ? */
        if (symbol == ' ' || symbol == '\t' || symbol == ',' || symbol == '\n') {
            
            /* ЕСЛИ СЛОВО/ЧИСЛО БЫЛО НЕПУСТЫМ (flag == 1) */
            if (flag == 1) {
                /* 1. Выводим накопленную сумму текущего слова/числа */
                printf("%d\n", sum);
                
                /* 2. Сбрасываем сумму для следующего слова/числа */
                sum = 0;
                
                /* 3. Сбрасываем флаг - слово завершено */
                flag = 0;
            }
            /* Если flag == 0, значит мы уже обработали предыдущее слово
               или идем подряд несколько разделителей - ничего не делаем */
        }
        
        /* ПРОВЕРКА: ЯВЛЯЕТСЯ ЛИ СИМВОЛ ЦИФРОЙ? */
        else if (symbol >= '0' && symbol <= '9') {
            /* Преобразуем символ цифры в числовое значение и добавляем к сумме:
               '0' -> 0, '1' -> 1, ..., '9' -> 9 */
            sum += symbol - '0';
            
            /* Устанавливаем флаг: слово содержит данные */
            flag = 1;
        }
        
        /* ВСЕ ОСТАЛЬНЫЕ СИМВОЛЫ (буквы, знаки препинания и т.д.) */
        else {
            /* Добавляем ASCII-код символа к сумме */
            sum += symbol;
            
            /* Устанавливаем флаг: слово содержит данные */
            flag = 1;
        }
    }
    
    /* ПОСЛЕ ЗАВЕРШЕНИЯ ВВОДА (достигнут EOF) */
    
    /* Проверяем, не осталось ли необработанное слово/число в буфере
       (это происходит, если файл не заканчивается разделителем) */
    if (flag == 1) {
        printf("%d\n", sum);
    }
    
    return 0;
}

/* 
 * ПОДРОБНЫЙ ПРИМЕР ВЫПОЛНЕНИЯ ПРОГРАММЫ:
 * 
 * Входные данные: "Привет 42\n"
 * Шаг 1: Читаем 'П' (кириллица, код > 127)
 *   - Не разделитель, не цифра → sum=<код_П>, flag=1
 * Шаг 2: Читаем 'р' 
 *   - Не разделитель, не цифра → sum+=<код_р>, flag=1
 * ... и так для всех букв "ривет"
 * Шаг N: Читаем ' ' (пробел)
 *   - Это разделитель И flag=1 → выводим сумму, sum=0, flag=0
 * Далее читаем '4', '2', затем '\n'
 *   - '4' и '2' цифры → sum=4+2=6, flag=1
 *   - '\n' разделитель → выводим 6
 * 
 * Результат:
 * <сумма кодов "Привет">
 * 6
 */