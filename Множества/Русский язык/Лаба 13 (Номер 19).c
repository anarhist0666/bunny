/*
 * ============================================================================
 *                              ЧТО ТАКОЕ UNICODE?
 * ============================================================================
 *
 * Unicode - это универсальный стандарт кодирования символов, который
 * присваивает уникальный номер (code point) КАЖДОМУ символу всех языков мира.
 *
 * ПРОБЛЕМА ASCII:
 *   ASCII кодирует только 128 символов (английские буквы, цифры, знаки).
 *   Для русского, китайского, арабского и других языков места не хватает!
 *
 * РЕШЕНИЕ - UNICODE:
 *   Диапазон: от 0 до 1,114,111 (более миллиона символов)
 *
 * ПРИМЕРЫ CODE POINTS:
 *   'A' = U+0041 (65)      - английская заглавная A
 *   'a' = U+0061 (97)      - английская строчная a
 *   'А' = U+0410 (1040)    - русская заглавная А
 *   'а' = U+0430 (1072)    - русская строчная а
 *   'я' = U+044F (1103)    - русская строчная я
 *   'ё' = U+0451 (1105)    - русская строчная ё (ВНИМАНИЕ: вне блока а-я!)
 *   '中' = U+4E2D (20013)  - китайский иероглиф "середина"
 *
 * РУССКИЙ АЛФАВИТ В UNICODE:
 *   А-Я (заглавные): U+0410 - U+042F (1040 - 1071), 32 буквы
 *   а-я (строчные):  U+0430 - U+044F (1072 - 1103), 32 буквы
 *   Ё (заглавная):   U+0401 (1025) - ОТДЕЛЬНО!
 *   ё (строчная):    U+0451 (1105) - ОТДЕЛЬНО!
 *
 * ============================================================================
 *                              КОДИРОВКА UTF-8
 * ============================================================================
 *
 * UTF-8 - способ ХРАНЕНИЯ Unicode в байтах. Это кодировка переменной длины:
 *
 * ┌─────────────────────┬────────────────────┬─────────────────────────────┐
 * │ Диапазон Unicode    │ Кол-во байт UTF-8  │ Формат байтов               │
 * ├─────────────────────┼────────────────────┼─────────────────────────────┤
 * │ U+0000 - U+007F     │ 1 байт             │ 0xxxxxxx                    │
 * │ (0 - 127)           │ (ASCII)            │                             │
 * ├─────────────────────┼────────────────────┼─────────────────────────────┤
 * │ U+0080 - U+07FF     │ 2 байта            │ 110xxxxx 10xxxxxx           │
 * │ (128 - 2047)        │ (русский тут!)     │                             │
 * ├─────────────────────┼────────────────────┼─────────────────────────────┤
 * │ U+0800 - U+FFFF     │ 3 байта            │ 1110xxxx 10xxxxxx 10xxxxxx  │
 * │ (2048 - 65535)      │                    │                             │
 * ├─────────────────────┼────────────────────┼─────────────────────────────┤
 * │ U+10000 - U+10FFFF  │ 4 байта            │ 11110xxx 10xx... 10xx...    │
 * │ (65536 - 1114111)   │                    │                             │
 * └─────────────────────┴────────────────────┴─────────────────────────────┘
 *
 * ПРИМЕР КОДИРОВАНИЯ БУКВЫ 'а' (U+0430 = 1072):
 *
 *   1. Unicode: 1072 в двоичном = 10000 110000 (11 бит)
 *
 *   2. Формат 2-байтного UTF-8: 110xxxxx 10xxxxxx
 *      Нужно разместить 11 бит:  xxxxx   xxxxxx
 *
 *   3. Разбиваем 10000110000 на части:
 *      Первые 5 бит:  10000
 *      Следующие 6 бит: 110000
 *
 *   4. Подставляем в шаблон:
 *      110|10000  10|110000
 *      = 11010000  10110000
 *      = 0xD0      0xB0
 *
 *   Итог: буква 'а' в UTF-8 = два байта: D0 B0
 *
 * ============================================================================
 *                          ЧТО ТАКОЕ UNSIGNED?
 * ============================================================================
 *
 * unsigned - модификатор типа, означающий "беззнаковый" (только >= 0).
 *
 * СРАВНЕНИЕ SIGNED И UNSIGNED:
 *
 * ┌─────────────────────┬──────────────────────────────────┬─────────────┐
 * │ Тип                 │ Диапазон значений                │ Размер      │
 * ├─────────────────────┼──────────────────────────────────┼─────────────┤
 * │ int                 │ -2,147,483,648 ... +2,147,483,647│ 4 байта     │
 * │ unsigned int        │ 0 ... 4,294,967,295              │ 4 байта     │
 * │ long long           │ -9.2×10^18 ... +9.2×10^18        │ 8 байт      │
 * │ unsigned long long  │ 0 ... 18.4×10^18                 │ 8 байт      │
 * └─────────────────────┴──────────────────────────────────┴─────────────┘
 *
 * КАК ВЫГЛЯДИТ В ПАМЯТИ (на примере 8-битного числа):
 *
 *   signed char:    диапазон -128 ... +127
 *                   -1 представляется как 11111111 (старший бит = знак)
 *                   +1 представляется как 00000001
 *                   -128 представляется как 10000000
 *
 *   unsigned char:  диапазон 0 ... 255
 *                   255 представляется как 11111111 (все биты = значение)
 *                   1   представляется как 00000001
 *                   128 представляется как 10000000
 *
 * ЗАЧЕМ НУЖЕН UNSIGNED В ЭТОЙ ПРОГРАММЕ:
 *
 *   1. Для кодов Unicode - они всегда положительные (0 - 1,114,111)
 *
 *   2. Для битовых масок - нам нужны все 64 бита для хранения множества,
 *      без "потери" старшего бита на знак
 *
 *   3. Для корректных битовых сдвигов - сдвиг вправо (>>) для signed
 *      может заполнять старшие биты единицами (арифметический сдвиг),
 *      а для unsigned всегда заполняет нулями (логический сдвиг)
 *
 *   4. EOF (-1) легко отличить от валидных Unicode-кодов
 *
 * ============================================================================
 *                         ФУНКЦИЯ GetUnicode()
 * ============================================================================
 *
 * unsigned int GetUnicode(void)
 *
 * НАЗНАЧЕНИЕ: Читает один UTF-8 символ из stdin (поток ввода) и возвращает его Unicode.
 *
 * АЛГОРИТМ ДЕКОДИРОВАНИЯ UTF-8:
 *
 * ШАГ 1. Читаем первый байт и определяем длину последовательности:
 *
 *   ┌────────────────────────────────────────────────────────────────────┐
 *   │ Первый байт           │ Маска   │ Результат │ Длина │ Значение     │
 *   ├───────────────────────┼─────────┼───────────┼───────┼──────────────┤
 *   │ 0xxxxxxx (0x00-0x7F)  │ & 0x80  │ == 0x00   │ 1     │ ASCII        │
 *   │ 110xxxxx (0xC0-0xDF)  │ & 0xE0  │ == 0xC0   │ 2     │ Русские тут! │
 *   │ 1110xxxx (0xE0-0xEF)  │ & 0xF0  │ == 0xE0   │ 3     │ Китайские    │
 *   │ 11110xxx (0xF0-0xF7)  │ & 0xF8  │ == 0xF0   │ 4     │ Emoji и др.  │
 *   └───────────────────────┴─────────┴───────────┴───────┴──────────────┘
 *
 *   Проверка для 1 байта: (firstByte & 0x80) == 0x00
 *     0x80 = 10000000
 *     Пример: 'A' = 01000001
 *             01000001 & 10000000 = 00000000 = 0x00 ✓
 *
 *   Проверка для 2 байтов: (firstByte & 0xE0) == 0xC0
 *     0xE0 = 11100000 (маска для первых 3 бит)
 *     0xC0 = 11000000 (ожидаемое значение первых 3 бит)
 *     Пример: первый байт 'а' = 0xD0 = 11010000
 *             11010000 & 11100000 = 11000000 = 0xC0 ✓
 *
 * ШАГ 2. Читаем дополнительные байты (если нужно):
 *
 *   Каждый дополнительный байт имеет формат 10xxxxxx
 *   Мы извлекаем младшие 6 бит маской 0x3F:
 *     0x3F = 00111111
 *     Пример: второй байт 'а' = 0xB0 = 10110000
 *             10110000 & 00111111 = 00110000 = 48
 *
 * ШАГ 3. Собираем Unicode code point:
 *
 *   Для 1 байта: просто младшие 7 бит первого байта
 *     letterCode = firstByte & 0x7F
 *
 *   Для 2 байтов: объединяем биты из обоих байтов
 *     letterCode = ((firstByte & 0x1F) << 6) | secondByte
 *
 *     0x1F = 00011111 (маска для 5 бит данных из первого байта)
 *
 *     Пример для 'а' (U+0430):
 *       firstByte = 0xD0 = 11010000
 *       secondByte (после & 0x3F) = 0x30 = 48 = 00110000
 *
 *       firstByte & 0x1F = 11010000 & 00011111 = 00010000 = 16
 *       16 << 6 = 16 * 64 = 1024 = 10000000000 (в двоичном)
 *       1024 | 48 = 10000000000 | 110000 = 10000110000 = 1072
 *
 *       Результат: 1072 = U+0430 = 'а' ✓
 *
 * ВОЗВРАЩАЕТ:
 *   - Unicode code point (0 - 2047 для 1-2 байтных символов)
 *   - EOF при конце ввода или ошибке
 *
 * ============================================================================
 *                         ФУНКЦИЯ ToUnicode()
 * ============================================================================
 *
 * unsigned int ToUnicode(char* symbol)
 *
 * НАЗНАЧЕНИЕ: Конвертирует UTF-8 строку-константу в Unicode code point.
 *             Используется для получения кодов символов в читаемом виде.
 *
 * ПАРАМЕТР: symbol - указатель на UTF-8 строку (например, "а", "Ё")
 *
 * АЛГОРИТМ: Аналогичен GetUnicode(), но читает из строки, а не из stdin.
 *
 * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
 *   ToUnicode("а") -> 1072 (U+0430)
 *   ToUnicode("я") -> 1103 (U+044F)
 *   ToUnicode("ё") -> 1105 (U+0451)
 *   ToUnicode("А") -> 1040 (U+0410)
 *   ToUnicode("A") -> 65   (U+0041, английская!)
 *
 * ЗАЧЕМ НУЖНА ЭТА ФУНКЦИЯ:
 *   Позволяет писать понятный код:
 *     ToUnicode("а") вместо магического числа 1072
 *     ToUnicode("я") - ToUnicode("а") вместо 1103 - 1072 = 31
 *
 * ============================================================================
 *                    ОПЕРАЦИИ С МНОЖЕСТВАМИ (БИТОВЫЕ МАСКИ)
 * ============================================================================
 *
 * ИДЕЯ БИТОВОГО МНОЖЕСТВА:
 *
 * Множество можно представить как последовательность битов, где:
 *   - Каждый элемент соответствует определённой позиции (биту)
 *   - Бит = 1 означает "элемент в множестве"
 *   - Бит = 0 означает "элемента нет в множестве"
 *
 * ПРИМЕНЕНИЕ К РУССКИМ БУКВАМ:
 *
 * Русские буквы а-я занимают диапазон U+0430 - U+044F (1072 - 1103).
 * Это 32 символа, они отлично помещаются в биты 0-31.
 *
 * Позиция буквы в множестве = код_буквы - код_'а' = код - 1072
 *
 *   'а' (1072) -> позиция 0
 *   'б' (1073) -> позиция 1
 *   'в' (1074) -> позиция 2
 *   ...
 *   'я' (1103) -> позиция 31
 *
 * ОСОБЫЙ СЛУЧАЙ - БУКВА 'ё':
 *   'ё' имеет код U+0451 (1105), который вне диапазона а-я!
 *   Поэтому для 'ё' выделена отдельная позиция - бит 33.
 *
 * ============================================================================
 *                    БИТОВЫЕ ОПЕРАЦИИ - ПОДРОБНОЕ ОБЪЯСНЕНИЕ
 * ============================================================================
 *
 * 1. СОЗДАНИЕ МАСКИ ДЛЯ ОДНОГО ЭЛЕМЕНТА: (1ULL << позиция)
 *
 *    1ULL - единица типа unsigned long long (64 бита)
 *    << - сдвиг влево на указанное количество позиций
 *
 *    Пример для буквы 'е' (позиция = 1077 - 1072 = 5):
 *      1ULL << 5 = 00000000...00100000 (единица на позиции 5)
 *
 *    Пример для буквы 'ё' (специальная позиция 33):
 *      1ULL << 33 = 00000010 00000000 00000000 00000000 00000000
 *                         ^
 *                      бит 33
 *
 * ─────────────────────────────────────────────────────────────────────────
 *
 * 2. ДОБАВЛЕНИЕ ЭЛЕМЕНТА В МНОЖЕСТВО: mask |= (1ULL << позиция)
 *
 *    Операция OR (|) устанавливает бит в 1, сохраняя остальные биты.
 *
 *    Пример - создаём множество гласных {а, е}:
 *
 *    Шаг 1: vowelMask = 0 (пустое множество)
 *           vowelMask = 00000000...00000000
 *
 *    Шаг 2: добавляем 'а' (позиция 0)
 *           vowelMask |= (1ULL << 0)
 *           00000000...00000000 | 00000000...00000001 = 00000000...00000001
 *
 *    Шаг 3: добавляем 'е' (позиция 5)
 *           vowelMask |= (1ULL << 5)
 *           00000000...00000001 | 00000000...00100000 = 00000000...00100001
 *
 *    Таблица истинности OR:
 *      0 | 0 = 0
 *      0 | 1 = 1
 *      1 | 0 = 1
 *      1 | 1 = 1  <- повторное добавление не меняет результат!
 *
 * ─────────────────────────────────────────────────────────────────────────
 *
 * 3. ПРОВЕРКА ПРИНАДЛЕЖНОСТИ: mask & (1ULL << позиция)
 *
 *    Операция AND (&) проверяет конкретный бит.
 *    Результат != 0 означает, что элемент в множестве.
 *
 *    Пример - проверяем, есть ли 'е' в множестве гласных:
 *
 *    vowelMask:      00000000...00100001 (есть а, е)
 *    1ULL << 5:      00000000...00100000 (маска для е)
 *    ───────────────────────────────────────────────
 *    Результат AND:  00000000...00100000 (не ноль -> е есть!)
 *
 *    Пример - проверяем 'б' (позиция 1):
 *
 *    vowelMask:      00000000...00100001
 *    1ULL << 1:      00000000...00000010
 *    ───────────────────────────────────────────────
 *    Результат AND:  00000000...00000000 (ноль -> б нет в множестве)
 *
 *    Таблица истинности AND:
 *      0 & 0 = 0
 *      0 & 1 = 0
 *      1 & 0 = 0
 *      1 & 1 = 1
 *
 * ─────────────────────────────────────────────────────────────────────────
 *
 * 4. ПОДСЧЁТ ЭЛЕМЕНТОВ (ЕДИНИЧНЫХ БИТОВ):
 *
 *    while (tempMask) {
 *        if (tempMask & 1) count++;  // проверяем младший бит
 *        tempMask >>= 1;              // сдвигаем вправо (делим на 2)
 *    }
 *
 *    Пример для множества {а, е} (маска = 00100001):
 *
 *    Итерация 1: tempMask = 00100001
 *                tempMask & 1 = 1 (младший бит = 1) -> count = 1
 *                tempMask >>= 1 -> 00010000
 *
 *    Итерация 2: tempMask = 00010000
 *                tempMask & 1 = 0 -> count = 1
 *                tempMask >>= 1 -> 00001000
 *
 *    ... (ещё 3 итерации с нулевыми битами)
 *
 *    Итерация 6: tempMask = 00000001
 *                tempMask & 1 = 1 -> count = 2
 *                tempMask >>= 1 -> 00000000
 *
 *    Выход: tempMask = 0, count = 2
 * ============================================================================
 */














#include <stdio.h>

/*
 * ============================================================================
 * ФУНКЦИЯ GetUnicode - читает один UTF-8 символ из stdin
 * ============================================================================
 * 
 * Возвращает:
 *   - Unicode code point (число от 0 до 2047 для 1-2 байтных символов)
 *   - EOF при конце ввода или ошибке декодирования
 */
unsigned int GetUnicode(void) {
    /*
     * Читаем первый байт символа.
     * getchar() возвращает int, чтобы вместить и символы (0-255), и EOF (-1).
     */
    int firstByte = getchar();
    
    /* Переменная для хранения количества байтов в UTF-8 последовательности */
    int byteCount = 0;

    /*
     * ========================================================================
     * ОПРЕДЕЛЕНИЕ ДЛИНЫ UTF-8 ПОСЛЕДОВАТЕЛЬНОСТИ
     * ========================================================================
     * 
     * Анализируем старшие биты первого байта, чтобы понять,
     * сколько байтов занимает символ.
     */
    
    /*
     * Проверка на однобайтный символ (ASCII):
     * 
     * Формат: 0xxxxxxx (старший бит = 0)
     * Маска:  0x80 = 10000000
     * 
     * Если (firstByte & 0x80) == 0x00, значит старший бит = 0 -> это ASCII.
     * 
     * Пример для 'A' (код 65 = 01000001):
     *   01000001 & 10000000 = 00000000 = 0x00 ✓ (это ASCII)
     */
    int isSingleByte = (firstByte & 0x80) == 0x00;
    
    /*
     * Проверка на двухбайтный символ:
     * 
     * Формат: 110xxxxx (первые три бита = 110)
     * Маска:  0xE0 = 11100000 (проверяем первые 3 бита)
     * Ожидаемый результат: 0xC0 = 11000000
     * 
     * Если (firstByte & 0xE0) == 0xC0, значит первые 3 бита = 110 -> 2 байта.
     * 
     * Пример для первого байта 'а' (0xD0 = 11010000):
     *   11010000 & 11100000 = 11000000 = 0xC0 ✓ (это 2-байтный символ)
     * 
     * Все русские буквы попадают в этот диапазон!
     */
    int isTwoByte = (firstByte & 0xE0) == 0xC0;

    /*
     * Устанавливаем количество байтов на основе проверок.
     * Если ни одна проверка не прошла - возвращаем EOF (ошибка/не поддерживается).
     */
    if (isSingleByte) {
        byteCount = 1;
    } else if (isTwoByte) {
        byteCount = 2;
    } else {
        /* 
         * Символ 3-4 байтный или невалидный.
         * Наша программа работает только с 1-2 байтными (ASCII + русский).
         */
        return EOF;
    }

    /*
     * ========================================================================
     * ЧТЕНИЕ ДОПОЛНИТЕЛЬНЫХ БАЙТОВ
     * ========================================================================
     */
    
    /* Переменная для хранения данных из второго байта (младшие 6 бит) */
    int secondByte = 0;
    int tempByte;

    if (byteCount >= 2) {
        /*
         * Для двухбайтных символов читаем второй байт.
         */
        tempByte = getchar();
        
        /* Проверка на неожиданный конец файла */
        if (tempByte == EOF) {
            return EOF;
        }
        
        /*
         * Извлекаем младшие 6 бит из второго байта.
         * 
         * Формат второго байта: 10xxxxxx
         * Маска: 0x3F = 00111111
         * 
         * Пример для второго байта 'а' (0xB0 = 10110000):
         *   10110000 & 00111111 = 00110000 = 48
         * 
         * Эти 6 бит - часть данных Unicode code point.
         */
        secondByte = tempByte & 0x3F;
    }

    /*
     * ========================================================================
     * СБОРКА UNICODE CODE POINT
     * ========================================================================
     */
    
    unsigned int letterCode = firstByte;

    if (byteCount == 1) {
        /*
         * Однобайтный символ (ASCII):
         * 
         * Формат: 0xxxxxxx
         * Маска: 0x7F = 01111111 (берём младшие 7 бит)
         * 
         * Пример для 'A' (65 = 01000001):
         *   01000001 & 01111111 = 01000001 = 65
         */
        letterCode = firstByte & 0x7F;
        
    } else if (byteCount == 2) {
        /*
         * Двухбайтный символ:
         * 
         * Формат: 110xxxxx 10yyyyyy
         * Нужно объединить xxxxx и yyyyyy в одно число: xxxxxyyyyyy
         * 
         * Алгоритм:
         *   1. Берём младшие 5 бит первого байта: firstByte & 0x1F
         *      0x1F = 00011111
         *   2. Сдвигаем их влево на 6 позиций: << 6
         *   3. Объединяем с 6 битами второго байта через OR: | secondByte
         * 
         * Пример для 'а' (U+0430 = 1072):
         *   Первый байт:  0xD0 = 11010000
         *   Второй байт:  0xB0 = 10110000 -> после & 0x3F = 00110000 = 48
         * 
         *   Шаг 1: 11010000 & 00011111 = 00010000 = 16
         *   Шаг 2: 16 << 6 = 16 * 64 = 1024
         *   Шаг 3: 1024 | 48 = 1024 + 48 = 1072
         * 
         *   Результат: 1072 = U+0430 = 'а' ✓
         */
        letterCode = ((firstByte & 0x1F) << 6) | secondByte;
    }

    return letterCode;
}

/*
 * ============================================================================
 * ФУНКЦИЯ ToUnicode - конвертирует UTF-8 строку в Unicode code point
 * ============================================================================
 * 
 * Параметр: symbol - указатель на UTF-8 строку (например, "а", "Ё")
 * 
 * Возвращает:
 *   - Unicode code point первого символа строки
 *   - 0 для пустой строки
 *   - EOF для неподдерживаемых символов
 * 
 * Эта функция нужна, чтобы писать понятный код:
 *   ToUnicode("а") вместо магического числа 1072
 */
unsigned int ToUnicode(char* symbol) {
    /*
     * Используем unsigned char, чтобы избежать проблем со знаковым расширением.
     * char может быть signed (-128..127), а нам нужны значения 0..255.
     */
    unsigned char firstByte = symbol[0];
    int byteCount = 0;

    /* Пустая строка - возвращаем 0 */
    if (firstByte == 0) {
        return 0;
    }

    /*
     * Определение длины UTF-8 последовательности - аналогично GetUnicode().
     */
    int isSingleByte = (firstByte & 0x80) == 0x00;
    int isTwoByte = (firstByte & 0xE0) == 0xC0;

    if (isSingleByte) {
        byteCount = 1;
    } else if (isTwoByte) {
        byteCount = 2;
    } else {
        return EOF;
    }

    int secondByte = 0;

    if (byteCount >= 2) {
        /*
         * Читаем второй байт из строки (не из stdin!).
         * symbol[1] - второй символ строки.
         */
        secondByte = symbol[1] & 0x3F;
    }

    /*
     * Сборка Unicode code point - аналогично GetUnicode().
     */
    unsigned int letterCode = firstByte;

    if (byteCount == 1) {
        letterCode = firstByte & 0x7F;
    } else if (byteCount == 2) {
        letterCode = ((firstByte & 0x1F) << 6) | secondByte;
    }
    
    return letterCode;
}


int main(void) {
    /*
     * ========================================================================
     * СОЗДАНИЕ МНОЖЕСТВА ГЛАСНЫХ БУКВ
     * ========================================================================
     * 
     * vowelMask - битовая маска, представляющая множество гласных.
     * 
     * unsigned long long = 64 бита, что позволяет хранить:
     *   - биты 0-31 для букв а-я (32 буквы)
     *   - бит 33 для буквы ё (она вне диапазона а-я в Unicode!)
     */
    unsigned long long vowelMask = 0;
    
    /*
     * Добавляем каждую гласную в множество.
     * 
     * Формула позиции: ToUnicode("буква") - ToUnicode("а")
     * 
     * Это даёт номер буквы в алфавите (начиная с 0):
     *   'а' -> 1072 - 1072 = 0
     *   'е' -> 1077 - 1072 = 5
     *   'и' -> 1080 - 1072 = 8
     *   и так далее...
     * 
     * Операция |= добавляет элемент в множество:
     *   1ULL << позиция - создаёт маску с единицей на нужной позиции
     *   mask |= маска   - устанавливает этот бит в множестве
     */
    
    /* 'а' - позиция 0 */
    vowelMask |= (1ULL << (ToUnicode("а") - ToUnicode("а")));
    
    /* 'е' - позиция 5 */
    vowelMask |= (1ULL << (ToUnicode("е") - ToUnicode("а")));
    
    /* 'и' - позиция 8 */
    vowelMask |= (1ULL << (ToUnicode("и") - ToUnicode("а")));
    
    /* 'о' - позиция 14 */
    vowelMask |= (1ULL << (ToUnicode("о") - ToUnicode("а")));
    
    /* 'у' - позиция 19 */
    vowelMask |= (1ULL << (ToUnicode("у") - ToUnicode("а")));
    
    /* 'ы' - позиция 27 */
    vowelMask |= (1ULL << (ToUnicode("ы") - ToUnicode("а")));
    
    /* 'э' - позиция 29 */
    vowelMask |= (1ULL << (ToUnicode("э") - ToUnicode("а")));
    
    /* 'ю' - позиция 30 */
    vowelMask |= (1ULL << (ToUnicode("ю") - ToUnicode("а")));
    
    /* 'я' - позиция 31 */
    vowelMask |= (1ULL << (ToUnicode("я") - ToUnicode("а")));
    
    /*
     * ОСОБЫЙ СЛУЧАЙ: буква 'ё'
     * 
     * В Unicode 'ё' имеет код U+0451 (1105), который находится
     * ПОСЛЕ 'я' (1103) и вне непрерывного диапазона а-я!
     * 
     * Поэтому для 'ё' мы используем отдельную позицию - бит 33.
     * (биты 0-31 заняты буквами а-я, бит 32 можно было бы использовать,
     * но выбран 33 для наглядности)
     */
    vowelMask |= (1ULL << 33);

    /*
     * Теперь vowelMask содержит единицы на позициях всех гласных:
     * 
     * Бит:     33  32  31  30  29  28  27  ...  19  ...  14  ...  8  ...  5  ...  0
     * Буква:    ё       я   ю   э       ы        у        о       и       е       а
     * Значение: 1   0   1   1   1   0   1   ...  1  ...   1  ...  1  ...  1  ...  1
     */

    /*
     * ========================================================================
     * ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ ДЛЯ ОБРАБОТКИ ТЕКСТА
     * ========================================================================
     */
    
    /* Флаг результата: 1 = нашли подходящее слово, 0 = не нашли */
    int result = 0;
    
    /* Текущий прочитанный символ (Unicode code point) */
    int highChar;
    
    /* Флаг: находимся ли мы внутри слова (1) или между словами (0) */
    int inWord = 0;
    
    /*
     * currentWordVowels - множество УНИКАЛЬНЫХ гласных в текущем слове.
     * 
     * Это тоже битовая маска: если слово содержит 'а' и 'о',
     * то currentWordVowels будет иметь единицы на позициях 0 и 14.
     * 
     * Ключевой момент: повторные вхождения одной гласной не считаются!
     * "мама" -> currentWordVowels = {а} (только одна уникальная гласная)
     * 
     * Это работает автоматически: установка уже установленного бита
     * ничего не меняет (1 | 1 = 1).
     */
    unsigned long long currentWordVowels = 0;
    
    /*
     * ========================================================================
     * ОСНОВНОЙ ЦИКЛ ОБРАБОТКИ ТЕКСТА
     * ========================================================================
     * 
     * Читаем символы один за другим, пока не достигнем конца файла (EOF).
     * Для каждого символа определяем:
     *   - это русская буква? -> обрабатываем как часть слова
     *   - это что-то другое? -> конец слова, проверяем результат
     */
    while ((highChar = GetUnicode()) != EOF) {
        
        /*
         * ====================================================================
         * ПРОВЕРКА: ЯВЛЯЕТСЯ ЛИ СИМВОЛ РУССКОЙ БУКВОЙ?
         * ====================================================================
         * 
         * Русские буквы в Unicode:
         *   а-я:  U+0430 - U+044F (1072 - 1103) - строчные
         *   А-Я:  U+0410 - U+042F (1040 - 1071) - заглавные
         *   ё:    U+0451 (1105) - строчная (отдельно!)
         *   Ё:    U+0401 (1025) - заглавная (отдельно!)
         */
        int isRussianLetter = 
            /* Строчные а-я */
            (highChar >= ToUnicode("а") && highChar <= ToUnicode("я")) ||
            /* Заглавные А-Я */
            (highChar >= ToUnicode("А") && highChar <= ToUnicode("Я")) ||
            /* Строчная ё */
            (highChar == ToUnicode("ё")) || 
            /* Заглавная Ё */
            (highChar == ToUnicode("Ё"));
        
        if (isRussianLetter) {
            /*
             * ================================================================
             * ОБРАБОТКА РУССКОЙ БУКВЫ
             * ================================================================
             */
            
            if (!inWord) {
                /*
                 * Начало нового слова:
                 *   - Устанавливаем флаг "мы в слове"
                 *   - Очищаем множество гласных для нового слова
                 */
                inWord = 1;
                currentWordVowels = 0;
            }
            
            /*
             * ================================================================
             * ПРИВЕДЕНИЕ К НИЖНЕМУ РЕГИСТРУ
             * ================================================================
             * 
             * Чтобы не проверять отдельно заглавные и строчные буквы,
             * приводим все буквы к строчным.
             * 
             * В Unicode для русских букв:
             *   'А' (1040) + 32 = 'а' (1072)
             *   'Б' (1041) + 32 = 'б' (1073)
             *   и так далее...
             * 
             * Разница: ToUnicode("а") - ToUnicode("А") = 1072 - 1040 = 32
             */
            unsigned int lowerChar = highChar;
            
            if (highChar >= ToUnicode("А") && highChar <= ToUnicode("Я")) {
                /* Заглавная буква А-Я -> добавляем 32 для получения строчной */
                lowerChar = highChar + (ToUnicode("а") - ToUnicode("А"));
                
            } else if (highChar == ToUnicode("Ё")) {
                /* Особый случай: Ё -> ё (нельзя просто добавить 32!) */
                lowerChar = ToUnicode("ё");
            }
            
            /*
             * ================================================================
             * ПРОВЕРКА НА ГЛАСНУЮ И ДОБАВЛЕНИЕ В МНОЖЕСТВО
             * ================================================================
             */
            
            if (lowerChar >= ToUnicode("а") && lowerChar <= ToUnicode("я")) {
                /*
                 * Буква из диапазона а-я.
                 * Вычисляем её позицию в алфавите.
                 */
                int charPos = lowerChar - ToUnicode("а");
                
                /*
                 * Проверяем, является ли буква гласной:
                 * 
                 * vowelMask & (1ULL << charPos)
                 * 
                 * 1ULL << charPos - создаёт маску с единицей на позиции charPos
                 * & - побитовое И с множеством гласных
                 * 
                 * Результат != 0, если буква - гласная.
                 * 
                 * Пример для 'о' (charPos = 14):
                 *   1ULL << 14 = 00000000...0100000000000000
                 *   vowelMask  = ...гласные на позициях 0,5,8,14,19,27,29,30,31,33...
                 *   Результат AND != 0, потому что бит 14 установлен в vowelMask
                 */
                if (vowelMask & (1ULL << charPos)) {
                    /*
                     * Буква - гласная! Добавляем её в множество текущего слова.
                     * 
                     * |= устанавливает бит, даже если он уже установлен.
                     * Это обеспечивает подсчёт УНИКАЛЬНЫХ гласных:
                     *   "мама" -> 'а' добавится дважды, но бит установится один раз
                     */
                    currentWordVowels |= (1ULL << charPos);
                }
                
            } else if (lowerChar == ToUnicode("ё")) {
                /*
                 * Особый случай: буква 'ё'.
                 * Она всегда гласная, добавляем на позицию 33.
                 */
                currentWordVowels |= (1ULL << 33);
            }
            
        } else {
            /*
             * ================================================================
             * СИМВОЛ - НЕ РУССКАЯ БУКВА (пробел, знак препинания, цифра...)
             * ================================================================
             * 
             * Это означает конец слова (если мы были в слове).
             */
            
            if (inWord) {
                /*
                 * ============================================================
                 * КОНЕЦ СЛОВА - ПОДСЧЁТ УНИКАЛЬНЫХ ГЛАСНЫХ
                 * ============================================================
                 * 
                 * Считаем количество единичных битов в currentWordVowels.
                 * Каждый единичный бит = одна уникальная гласная.
                 */
                int vowelCount = 0;
                unsigned long long tempMask = currentWordVowels;
                
                /*
                 * Алгоритм подсчёта битов:
                 * 
                 * 1. Проверяем младший бит: tempMask & 1
                 *    Если он равен 1, увеличиваем счётчик.
                 * 
                 * 2. Сдвигаем маску вправо на 1: tempMask >>= 1
                 *    Это "выбрасывает" проверенный бит и подставляет следующий.
                 * 
                 * 3. Повторяем, пока маска не станет 0 (все биты проверены).
                 * 
                 * Пример для currentWordVowels = 0b100001 (гласные а и е):
                 * 
                 * Итерация 1: tempMask = 100001, & 1 = 1, count = 1
                 *             tempMask >>= 1 -> 010000
                 * 
                 * Итерация 2: tempMask = 010000, & 1 = 0, count = 1
                 *             tempMask >>= 1 -> 001000
                 * 
                 * ... (ещё 3 итерации с 0) ...
                 * 
                 * Итерация 6: tempMask = 000001, & 1 = 1, count = 2
                 *             tempMask >>= 1 -> 000000
                 * 
                 * Выход: tempMask = 0, count = 2 (две уникальные гласные)
                 */
                while (tempMask) {
                    if (tempMask & 1) {
                        vowelCount += 1;
                    }
                    tempMask >>= 1;
                }
                
                /*
                 * Если в слове ровно одна уникальная гласная,
                 * устанавливаем флаг результата.
                 */
                if (vowelCount == 1) {
                    result = 1;
                }
                
                /* Сбрасываем состояние для следующего слова */
                inWord = 0;
                currentWordVowels = 0;
            }
        }
    }
    
    /*
     * ========================================================================
     * ОБРАБОТКА ПОСЛЕДНЕГО СЛОВА
     * ========================================================================
     * 
     * Если текст заканчивается буквой (без пробела или перевода строки),
     * последнее слово не будет обработано в цикле.
     * 
     * Пример: "привет" (без \n в конце)
     *         После чтения 'т' мы всё ещё inWord = 1, но цикл завершается.
     * 
     * Поэтому нужна дополнительная проверка после цикла.
     */
    if (inWord) {
        /* Аналогичный подсчёт гласных, как в цикле выше */
        int vowelCount = 0;
        unsigned long long tempMask = currentWordVowels;
        
        while (tempMask) {
            if (tempMask & 1) {
                vowelCount += 1;
            }
            tempMask >>= 1;
        }
        
        if (vowelCount == 1) {
            result = 1;
        }
    }
    
    /*
     * ========================================================================
     * ВЫВОД РЕЗУЛЬТАТА
     * ========================================================================
     */
    if (result) {
        /* Нашли хотя бы одно слово с ровно одной уникальной гласной */
        printf("YES\n");
    } else {
        /* Такого слова не нашли */
        printf("NO\n");
    }
    
    return 0;
}