/*
 * ============================================================================
 *                              ЧТО ТАКОЕ ASCII?
 * ============================================================================
 *
 * ASCII (American Standard Code for Information Interchange) - это стандарт
 * кодирования символов, где каждому символу соответствует число от 0 до 127.
 *
 * Примеры кодов ASCII:
 *   'A' = 65,  'B' = 66,  ..., 'Z' = 90   (заглавные буквы)
 *   'a' = 97,  'b' = 98,  ..., 'z' = 122  (строчные буквы)
 *   '0' = 48,  '1' = 49,  ..., '9' = 57   (цифры)
 *   ' ' = 32 (пробел), '\n' = 10 (перевод строки)
 *
 * Важное свойство: старший бит (бит 7) у ASCII-символов всегда равен 0.
 * Поэтому проверка (ch & 0x80) != 0 определяет НЕ-ASCII символы.
 *
 *   0x80 в двоичном виде: 10000000
 *   ASCII символ 'A'(65): 01000001  ->  01000001 & 10000000 = 00000000 (OK)
 *   Не-ASCII (например 200): 11001000  ->  11001000 & 10000000 = 10000000 (НЕ OK)
 *
 * ============================================================================
 *                          ЧТО ТАКОЕ UNSIGNED?
 * ============================================================================
 *
 * unsigned - модификатор типа, означающий "беззнаковый" (только >= 0).
 *
 * СРАВНЕНИЕ SIGNED И UNSIGNED:
 *
 *   Тип                    Диапазон значений           Размер
 *   ─────────────────────────────────────────────────────────────
 *   int                    -2,147,483,648 ... +2,147,483,647    4 байта
 *   unsigned int           0 ... 4,294,967,295                  4 байта
 *   long long              -9.2×10^18 ... +9.2×10^18            8 байт
 *   unsigned long long     0 ... 18.4×10^18                     8 байт
 *
 * КАК ВЫГЛЯДИТ В ПАМЯТИ (на примере 8-битного числа):
 *
 *   signed char:    диапазон -128 ... +127
 *                   -1 представляется как 11111111
 *                   +1 представляется как 00000001
 *
 *   unsigned char:  диапазон 0 ... 255
 *                   255 представляется как 11111111
 *                   1   представляется как 00000001
 *
 * ЗАЧЕМ НУЖЕН UNSIGNED В ЭТОЙ ПРОГРАММЕ:
 *   1. Для битовых операций - избегаем проблем со знаковым битом
 *   2. Для масок - нам нужны только положительные значения
 *   3. EOF (-1) легко отличить от валидных кодов (0-127)
 *
 * ============================================================================
 *                         ФУНКЦИЯ GetASCII()
 * ============================================================================
 *
 * unsigned int GetASCII(void)
 *
 * НАЗНАЧЕНИЕ: Читает один символ из входного потока (stdin) и возвращает
 *             его ASCII-код, если символ валидный.
 *
 * АЛГОРИТМ:
 *   1. getchar() читает символ (возвращает int, чтобы вместить EOF)
 *   2. Проверяем на EOF (конец файла/ввода)
 *   3. Проверяем, что это ASCII: (ch & 0x80) должно быть 0
 *   4. Возвращаем код символа или EOF при ошибке
 *
 * ВОЗВРАЩАЕТ:
 *   - ASCII-код символа (0-127) при успехе
 *   - EOF (-1) при конце ввода или не-ASCII символе
 *
 * ПРИМЕР РАБОТЫ:
 *   Ввод: 'H'
 *   getchar() возвращает 72
 *   72 & 0x80 = 01001000 & 10000000 = 0 (это ASCII)
 *   Возврат: 72
 *
 * ============================================================================
 *                         ФУНКЦИЯ ToASCII()
 * ============================================================================
 *
 * unsigned int ToASCII(char* symbol)
 *
 * НАЗНАЧЕНИЕ: Конвертирует первый символ строки в его ASCII-код.
 *             Используется для получения кодов констант ("a", "A" и т.д.)
 *
 * ПАРАМЕТР: symbol - указатель на строку (например, "a", "Z")
 *
 * АЛГОРИТМ:
 *   1. Берём первый байт строки: symbol[0]
 *   2. Проверяем на пустую строку (если 0 - возвращаем 0)
 *   3. Проверяем на ASCII (старший бит должен быть 0)
 *   4. Возвращаем код символа
 *
 * ВОЗВРАЩАЕТ:
 *   - ASCII-код первого символа строки (0-127)
 *   - 0 для пустой строки
 *   - EOF для не-ASCII символов
 *
 * ПРИМЕРЫ:
 *   ToASCII("a") -> 97
 *   ToASCII("A") -> 65
 *   ToASCII("z") -> 122
 *   ToASCII("а") -> EOF (русская буква, не ASCII!)
 *
 * ============================================================================
 *                    ОПЕРАЦИИ С МНОЖЕСТВАМИ (БИТОВЫЕ МАСКИ)
 * ============================================================================
 *
 * В программе множество представлено как БИТОВАЯ МАСКА.
 * Каждый бит соответствует одной букве алфавита.
 *
 * ИДЕЯ:
 *   - Позиция буквы = код_буквы - код_'a'
 *   - 'a' -> позиция 0,  'b' -> позиция 1, ..., 'z' -> позиция 25
 *   - Если буква в множестве, соответствующий бит = 1
 *
 * ПРЕДСТАВЛЕНИЕ МНОЖЕСТВА ГЛАСНЫХ {a, e, i, o, u}:
 *
 *   Буква:   z  y  x  ... u  t  s  ... o  ... i ... e ... a
 *   Позиция: 25 24 23 ... 20 19 18 ... 14 ... 8 ... 4 ... 0
 *   Бит:      0  0  0 ... 1  0  0  ... 1  ... 1 ... 1 ... 1
 *
 *   vowelMask = 00000000 00000000 00000000 00000000
 *               00000000 00010000 01000001 00010001
 *                           ^u     ^o    ^i   ^e  ^a
 *
 * ============================================================================
 *                    БИТОВЫЕ ОПЕРАЦИИ - ПОДРОБНОЕ ОБЪЯСНЕНИЕ
 * ============================================================================
 *
 * 1. СОЗДАНИЕ МАСКИ ДЛЯ ОДНОГО ЭЛЕМЕНТА: (1ULL << позиция)
 *
 *    1ULL - это число 1 типа unsigned long long (64 бита)
 *    << - сдвиг влево на указанное количество позиций
 *
 *    Пример для буквы 'e' (позиция 4):
 *    1ULL << 4 = 00000000...00010000 (единица на позиции 4)
 *
 *    Пример для буквы 'a' (позиция 0):
 *    1ULL << 0 = 00000000...00000001 (единица на позиции 0)
 *
 * ─────────────────────────────────────────────────────────────────────────
 *
 * 2. ДОБАВЛЕНИЕ ЭЛЕМЕНТА В МНОЖЕСТВО: mask |= (1ULL << позиция)
 *
 *    Операция OR (|) устанавливает бит в 1, не затрагивая остальные.
 *
 *    Пример - добавляем 'e' к множеству, где уже есть 'a':
 *
 *    vowelMask (до):   00000000...00000001  (есть 'a')
 *    1ULL << 4:        00000000...00010000  (маска для 'e')
 *    ─────────────────────────────────────
 *    vowelMask (после): 00000000...00010001  (есть 'a' и 'e')
 *
 *    Таблица истинности OR:
 *      0 | 0 = 0
 *      0 | 1 = 1
 *      1 | 0 = 1
 *      1 | 1 = 1
 *
 * ─────────────────────────────────────────────────────────────────────────
 *
 * 3. ПРОВЕРКА ПРИНАДЛЕЖНОСТИ: mask & (1ULL << позиция)
 *
 *    Операция AND (&) проверяет, установлен ли конкретный бит.
 *    Результат != 0, если элемент в множестве.
 *
 *    Пример - проверяем, есть ли 'e' в множестве {a, e}:
 *
 *    vowelMask:      00000000...00010001  (есть 'a' и 'e')
 *    1ULL << 4:      00000000...00010000  (маска для 'e')
 *    ─────────────────────────────────────
 *    Результат:      00000000...00010000  (!= 0, значит 'e' есть)
 *
 *    Пример - проверяем, есть ли 'b' (позиция 1):
 *
 *    vowelMask:      00000000...00010001
 *    1ULL << 1:      00000000...00000010
 *    ─────────────────────────────────────
 *    Результат:      00000000...00000000  (== 0, значит 'b' нет)
 *
 *    Таблица истинности AND:
 *      0 & 0 = 0
 *      0 & 1 = 0
 *      1 & 0 = 0
 *      1 & 1 = 1
 *
 * ─────────────────────────────────────────────────────────────────────────
 *
 * 4. ПОДСЧЁТ ЭЛЕМЕНТОВ В МНОЖЕСТВЕ:
 *
 *    while (tempMask) {
 *        if (tempMask & 1) vowelCount++;  // проверяем младший бит
 *        tempMask >>= 1;                   // сдвигаем вправо
 *    }
 *
 *    Пример для множества {a, e} (маска = 00010001):
 *
 *    Итерация 1: tempMask = 00010001, младший бит = 1, count = 1
 *    Итерация 2: tempMask = 00001000, младший бит = 0, count = 1
 *    Итерация 3: tempMask = 00000100, младший бит = 0, count = 1
 *    Итерация 4: tempMask = 00000010, младший бит = 0, count = 1
 *    Итерация 5: tempMask = 00000001, младший бит = 1, count = 2
 *    Итерация 6: tempMask = 00000000, выход из цикла
 *
 *    Результат: 2 элемента в множестве
 * ============================================================================
 */










// Условие: Есть ли слово, содержащее одну гласную, возможно несколько раз?

#include <stdio.h>

/*
 * Функция GetASCII - читает один ASCII-символ из входного потока
 * 
 * Возвращает:
 *   - ASCII-код символа (0-127) при успешном чтении
 *   - EOF при конце ввода или если символ не является ASCII
 */
unsigned int GetASCII(void) {
    /* 
     * getchar() возвращает int, а не char, потому что:
     * - Нужно вместить все значения 0-255 И специальное значение EOF (-1)
     * - char может быть знаковым, что создаст проблемы с EOF
     */
    int ch = getchar();

    /*
     * Проверка на валидность символа:
     * 
     * 1) ch == EOF - конец файла или ошибка ввода
     * 
     * 2) (ch & 0x80) != 0 - проверка старшего бита:
     *    
     *    0x80 в двоичном виде: 10000000
     *    
     *    Для ASCII-символов (0-127) старший бит всегда 0:
     *      'A' (65):  01000001 & 10000000 = 00000000 (OK, это ASCII)
     *      'z' (122): 01111010 & 10000000 = 00000000 (OK, это ASCII)
     *    
     *    Для не-ASCII символов (128-255) старший бит = 1:
     *      символ 200: 11001000 & 10000000 = 10000000 (НЕ ASCII!)
     */
    if (ch == EOF || (ch & 0x80) != 0) {
        return EOF;  /* Возвращаем EOF как сигнал об ошибке/конце */
    }

    /* Приводим к unsigned int и возвращаем */
    return (unsigned int)ch;
}

/*
 * Функция ToASCII - получает ASCII-код первого символа строки
 * 
 * Параметр: symbol - указатель на C-строку (например, "a", "Z")
 * 
 * Возвращает:
 *   - ASCII-код первого символа
 *   - 0 для пустой строки
 *   - EOF для не-ASCII символов
 * 
 * Используется для получения кодов символов-констант в читаемом виде:
 *   ToASCII("a") вместо магического числа 97
 */
unsigned int ToASCII(char* symbol) {
    /*
     * Используем unsigned char, чтобы избежать проблем со знаком
     * при сравнении с 0x80
     */
    unsigned char firstByte = symbol[0];

    /* Пустая строка - первый байт равен нулевому терминатору */
    if (firstByte == 0) {
        return 0;
    }

    /*
     * Проверка на ASCII - аналогично GetASCII()
     * Если старший бит = 1, это не ASCII-символ
     */
    if (firstByte & 0x80) {
        return EOF;
    }

    return firstByte;
}


int main(void) {
    /*
     * =========================================================================
     * СОЗДАНИЕ МНОЖЕСТВА ГЛАСНЫХ БУКВ
     * =========================================================================
     * 
     * Используем битовую маску для представления множества.
     * unsigned long long = 64 бита, нам нужно всего 26 (для a-z).
     * 
     * Идея: каждая буква алфавита соответствует одному биту.
     *   Позиция буквы = код_буквы - код_'a'
     *   'a' -> бит 0,  'b' -> бит 1, ..., 'z' -> бит 25
     * 
     * Если буква входит в множество, её бит = 1, иначе = 0.
     */
    unsigned long long vowelMask = 0;

    /*
     * Добавляем гласные в множество с помощью операции OR (|=)
     * 
     * Формула: 1U << (код_буквы - код_'a')
     * 
     * Пример для 'a':
     *   ToASCII("a") - ToASCII("a") = 97 - 97 = 0
     *   1U << 0 = 00000000...00000001 (единица на позиции 0)
     * 
     * Пример для 'e':
     *   ToASCII("e") - ToASCII("a") = 101 - 97 = 4
     *   1U << 4 = 00000000...00010000 (единица на позиции 4)
     * 
     * Операция |= добавляет новый бит, не затрагивая существующие:
     *   00000001 |= 00010000 -> 00010001 (теперь есть и 'a', и 'e')
     */
    vowelMask |= (1U << (ToASCII("a") - ToASCII("a")));  /* позиция 0 */
    vowelMask |= (1U << (ToASCII("e") - ToASCII("a")));  /* позиция 4 */
    vowelMask |= (1U << (ToASCII("i") - ToASCII("a")));  /* позиция 8 */
    vowelMask |= (1U << (ToASCII("o") - ToASCII("a")));  /* позиция 14 */
    vowelMask |= (1U << (ToASCII("u") - ToASCII("a")));  /* позиция 20 */
    
    /*
     * После всех операций vowelMask выглядит так (показаны биты 0-25):
     * 
     * Позиция: 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
     * Буква:    z  y  x  w  v  u  t  s  r  q  p  o  n  m  l  k  j  i  h  g  f  e  d  c  b  a
     * Бит:      0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  1  0  0  0  1
     */

    int result = 0;           /* Флаг: нашли ли подходящее слово */
    int highChar;             /* Текущий прочитанный символ */
    int inWord = 0;           /* Флаг: находимся ли внутри слова */
    
    /*
     * currentWordVowels - множество УНИКАЛЬНЫХ гласных в текущем слове
     * 
     * Это тоже битовая маска: если слово содержит 'a' и 'e',
     * то currentWordVowels = 00010001 (биты 0 и 4 установлены)
     * 
     * Повторные вхождения одной гласной не увеличивают счётчик,
     * потому что установка уже установленного бита ничего не меняет:
     *   00010001 |= 00000001 -> 00010001 (бит 'a' уже был)
     */
    unsigned long long currentWordVowels = 0;
    
    /*
     * =========================================================================
     * ОСНОВНОЙ ЦИКЛ ОБРАБОТКИ ВВОДА
     * =========================================================================
     * 
     * Читаем символы до EOF, определяем границы слов,
     * собираем информацию о гласных в каждом слове.
     */
    while ((highChar = GetASCII()) != EOF) {
        
        /*
         * Определяем, является ли символ буквой (a-z или A-Z)
         * 
         * Проверка через сравнение с диапазонами:
         *   'a'(97) <= highChar <= 'z'(122)  ИЛИ
         *   'A'(65) <= highChar <= 'Z'(90)
         */
        int isLetter = (highChar >= ToASCII("a") && highChar <= ToASCII("z")) ||
                       (highChar >= ToASCII("A") && highChar <= ToASCII("Z"));
        
        if (isLetter) {
            /*
             * Символ - буква, мы внутри слова
             */
            
            if (!inWord) {
                /*
                 * Начало нового слова:
                 * - Устанавливаем флаг
                 * - Очищаем множество гласных для нового слова
                 */
                inWord = 1;
                currentWordVowels = 0;
            }
            
            /*
             * Приводим букву к нижнему регистру для унификации
             * 
             * В ASCII: 'A'=65, 'a'=97, разница = 32
             * Для преобразования: заглавная + 32 = строчная
             * 
             * ToASCII("a") - ToASCII("A") = 97 - 65 = 32
             */
            unsigned int lowerChar = highChar;
            if (highChar >= ToASCII("A") && highChar <= ToASCII("Z")) {
                lowerChar = highChar + (ToASCII("a") - ToASCII("A"));
            }
            
            /*
             * Проверяем, является ли буква гласной, и если да - добавляем
             * в множество гласных текущего слова
             */
            if (lowerChar >= ToASCII("a") && lowerChar <= ToASCII("z")) {
                
                /* Вычисляем позицию буквы в алфавите (0-25) */
                int charPos = lowerChar - ToASCII("a");
                
                /*
                 * Проверка принадлежности к множеству гласных:
                 * 
                 * vowelMask & (1ULL << charPos)
                 * 
                 * Создаём маску с единицей на позиции charPos,
                 * затем делаем AND с множеством гласных.
                 * 
                 * Результат != 0, если буква - гласная.
                 * 
                 * Пример для 'e' (charPos = 4):
                 *   vowelMask:     ...00010001 00010001 (гласные a,e,i,o,u)
                 *   1ULL << 4:     ...00000000 00010000
                 *   AND:           ...00000000 00010000 (не ноль -> 'e' гласная)
                 * 
                 * Пример для 'b' (charPos = 1):
                 *   vowelMask:     ...00010001 00010001
                 *   1ULL << 1:     ...00000000 00000010
                 *   AND:           ...00000000 00000000 (ноль -> 'b' не гласная)
                 */
                if (vowelMask & (1ULL << charPos)) {
                    /*
                     * Буква - гласная, добавляем в множество текущего слова
                     * 
                     * Операция |= устанавливает бит, даже если он уже установлен.
                     * Это автоматически обеспечивает уникальность:
                     * "bee" -> 'e' добавится один раз, несмотря на две буквы 'e'
                     */
                    currentWordVowels |= (1ULL << charPos);
                }
            }
        } else {
            /*
             * Символ - не буква (пробел, пунктуация, цифра и т.д.)
             * Это означает конец слова (если мы были в слове)
             */
            
            if (inWord) {
                /*
                 * Конец слова - подсчитываем количество УНИКАЛЬНЫХ гласных
                 * 
                 * Алгоритм: считаем количество единичных битов в маске
                 */
                int vowelCount = 0;
                unsigned long long tempMask = currentWordVowels;
                
                /*
                 * Цикл подсчёта битов:
                 * 
                 * Проверяем младший бит (tempMask & 1), затем сдвигаем вправо.
                 * Повторяем, пока маска не станет нулём.
                 * 
                 * Пример для currentWordVowels = 00010001 (гласные a и e):
                 * 
                 * Итерация 1: tempMask = 00010001
                 *             tempMask & 1 = 1 (младший бит = 1)
                 *             vowelCount = 1
                 *             tempMask >>= 1 -> 00001000
                 * 
                 * Итерация 2: tempMask = 00001000
                 *             tempMask & 1 = 0
                 *             tempMask >>= 1 -> 00000100
                 * 
                 * Итерация 3: tempMask = 00000100
                 *             tempMask & 1 = 0
                 *             tempMask >>= 1 -> 00000010
                 * 
                 * Итерация 4: tempMask = 00000010
                 *             tempMask & 1 = 0
                 *             tempMask >>= 1 -> 00000001
                 * 
                 * Итерация 5: tempMask = 00000001
                 *             tempMask & 1 = 1
                 *             vowelCount = 2
                 *             tempMask >>= 1 -> 00000000
                 * 
                 * Выход: tempMask = 0, vowelCount = 2
                 */
                while (tempMask) {
                    if (tempMask & 1) {
                        vowelCount += 1;
                    }
                    tempMask >>= 1;
                }
                
                /*
                 * Если в слове ровно одна уникальная гласная - 
                 * устанавливаем флаг результата
                 */
                if (vowelCount == 1) {
                    result = 1;
                }
                
                /* Сбрасываем состояние для следующего слова */
                inWord = 0;
                currentWordVowels = 0;
            }
        }
    }
    
    /*
     * =========================================================================
     * ОБРАБОТКА ПОСЛЕДНЕГО СЛОВА
     * =========================================================================
     * 
     * Если файл заканчивается без разделителя после последнего слова,
     * нужно обработать его отдельно.
     * 
     * Пример: "hello world" (без \n в конце)
     *         После чтения 'd' мы всё ещё inWord = 1
     */
    if (inWord) {
        int vowelCount = 0;
        unsigned long long tempMask = currentWordVowels;
        
        /* Аналогичный подсчёт битов */
        while (tempMask) {
            if (tempMask & 1) {
                vowelCount += 1;
            }
            tempMask >>= 1;
        }
        
        if (vowelCount == 1) {
            result = 1;
        }
    }
    
    /*
     * =========================================================================
     * ВЫВОД РЕЗУЛЬТАТА
     * =========================================================================
     */
    if (result) {
        printf("YES\n");  /* Найдено слово с одной уникальной гласной */
    } else {
        printf("NO\n");   /* Такого слова не найдено */
    }
    
    return 0;
}