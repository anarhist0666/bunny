/*
 * ============================================================================
 *
 * 1. ФУНКЦИЯ `scanf()` ДЛЯ ФОРМАТИРОВАННОГО ВВОДА
 *    Функция `scanf()` из библиотеки <stdio.h> читает форматированные данные
 *    из стандартного входного потока (обычно с клавиатуры).
 *
 *    Синтаксис: 
 *        int scanf("строка_формата", &переменная1, &переменная2, ...);
 *
 *    ─────────────────────────────────────────────────────────────────────────
 *    ОПЕРАТОР `&` (амперсанд) - ОПЕРАТОР ВЗЯТИЯ АДРЕСА
 *    ─────────────────────────────────────────────────────────────────────────
 *    
 *    Что такое `&`:
 *    - Унарный оператор, который возвращает АДРЕС переменной в памяти
 *    - Читается как "адрес переменной" или "указатель на переменную"
 *    
 *    Зачем нужен `&` в scanf():
 *    - scanf() должна ИЗМЕНИТЬ значение переменной, которую мы передаём
 *    - В C аргументы передаются ПО ЗНАЧЕНИЮ (копируются)
 *    - Если передать просто `num`, scanf получит КОПИЮ значения
 *    - Изменение копии не повлияет на оригинальную переменную!
 *    - Передавая `&num`, мы даём scanf АДРЕС, куда записать результат
 *
 *    Аналогия из жизни:
 *    ┌─────────────────────────────────────────────────────────────────────┐
 *    │ Представьте, что вы заказываете доставку пиццы:                     │
 *    │                                                                     │
 *    │ БЕЗ адреса (&):  "Привезите пиццу!" → Курьер: "Куда везти?!"        │
 *    │ С адресом (&):   "Привезите пиццу на ул. Ленина, 15" → Доставлено!  │
 *    │                                                                     │
 *    │ scanf("%d", num)   → scanf знает ЗНАЧЕНИЕ num, но не знает КУДА     │
 *    │                      записать прочитанное число                     │
 *    │ scanf("%d", &num)  → scanf знает АДРЕС num и может туда записать    │
 *    └─────────────────────────────────────────────────────────────────────┘
 *
 *    Визуализация работы:
 *    
 *    int num;                    // Переменная num находится по адресу 0x1000
 *                                // ┌───────────┐
 *    Память: адрес 0x1000 →         │   ???     │  (мусор до инициализации)
 *                                // └───────────┘
 *    
 *    scanf("%d", &num);          // &num = 0x1000 (адрес переменной)
 *                                // scanf записывает число 42 по адресу 0x1000
 *                                // ┌───────────┐
 *    Память: адрес 0x1000 →         │    42     │  (теперь здесь 42)
 *                                // └───────────┘
 *
 *    Типичные ошибки:
 *    
 *    int num;
 *    scanf("%d", num);    // ❌ ОШИБКА! Передаётся значение num (мусор)
 *                         //    scanf попытается записать по "мусорному" адресу
 *                         //    Результат: сбой программы или повреждение памяти
 *    
 *    scanf("%d", &num);   // ✓ ПРАВИЛЬНО! Передаётся адрес переменной num
 *
 *    Исключение - строки (массивы символов):
 *    
 *    char name[50];
 *    scanf("%s", name);   // ✓ Без & ! Имя массива УЖЕ является адресом
 *                         //   name эквивалентно &name[0]
 *
 *    ─────────────────────────────────────────────────────────────────────────
 *
 *    Работа функции scanf():
 *    1. ПРОПУСК ПРОБЕЛЬНЫХ СИМВОЛОВ:
 *       - При чтении чисел (%d, %f) scanf автоматически пропускает "пробельные символы":
 *         пробелы ' ', табуляции '\t', переносы строк '\n'
 *       - Это позволяет вводить числа с любым количеством пробелов между ними
 *
 *    2. ЧТЕНИЕ И ПРЕОБРАЗОВАНИЕ:
 *       - scanf анализирует ввод согласно спецификаторам формата
 *       - Для %d: читает последовательность цифр, знак +/-
 *       - Преобразует строковое представление числа в бинарное целое число
 *
 *    3. ПРЕКРАЩЕНИЕ ЧТЕНИЯ:
 *       - Останавливается при первом несоответствующем символе
 *       - Например: для "%d" при первом не-цифре (буква, точка и т.д.)
 *
 *    4. ПРИСВАИВАНИЕ ЗНАЧЕНИЙ:
 *       - Записывает прочитанные значения по переданным адресам (&переменная)
 *       - Без & оператора функция не знала бы, куда в памяти записать значение
 *
 *    5. ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
 *       - Возвращает количество УСПЕШНО прочитанных и присвоенных элементов
 *       - Возвращает EOF (обычно -1) при достижении конца файла или ошибке ввода
 *
 *    В данном коде: 
 *        while (scanf("%d", &num) == 1)
 *    Это означает: "пока удаётся прочитать и преобразовать одно целое число"
 *
 *    Завершение ввода:
 *        - Linux/macOS: Ctrl + D отправляет EOF
 *        - Windows: Ctrl + Z, затем Enter
 *        - Любой нечисловой символ (буква) также прервёт чтение
 *
 *    Примеры работы scanf():
 *        Ввод "123" → успешно читает 123, возвращает 1
 *        Ввод "  456  " → пропускает пробелы, читает 456, возвращает 1  
 *        Ввод "abc" → не может прочитать число, возвращает 0
 *        Ввод "123 abc" → читает 123, возвращает 1, " abc" остаётся в буфере
 *
 * ============================================================================
 *
 * 2. ОПЕРАТОР `continue` ДЛЯ ПРОПУСКА ИТЕРАЦИИ
 *    Оператор `continue` используется внутри циклов для немедленного перехода
 *    к следующей итерации, пропуская оставшийся код текущей итерации.
 *
 *    Механика работы:
 *    1. При встрече `continue` выполнение текущей итерации прерывается
 *    2. Управление передаётся на проверку условия цикла
 *    3. Если условие истинно - начинается следующая итерация
 *
 *    Синтаксис:
 *        while (условие) {
 *            // код, который выполняется всегда
 *            
 *            if (условие_для_пропуска) {
 *                continue;  // ← переход к while (условие)
 *            }
 *            
 *            // код, который пропускается при срабатывании continue
 *        }
 *
 *    В данном коде:
 *        if (num == 0) {
 *            printf("0\n");
 *            continue;  // пропускаем всю остальную обработку для числа 0
 *        }
 *
 *    Важно: `continue` работает только с самым внутренним циклом, в котором находится.
 *
 * ============================================================================
 *
 * 3. ОПЕРАТОР `break` ДЛЯ ДОСРОЧНОГО ВЫХОДА ИЗ ЦИКЛА
 *    Оператор `break` используется для немедленного завершения выполнения цикла.
 *
 *    Механика работы:
 *    1. При встрече `break` выполнение цикла немедленно прекращается
 *    2. Управление передаётся на первую инструкцию ПОСЛЕ цикла
 *    3. Все оставшиеся итерации пропускаются
 *
 *    Синтаксис:
 *        while (условие) {
 *            // код до break
 *            
 *            if (условие_для_выхода) {
 *                break;  // ← немедленный выход из цикла
 *            }
 *            
 *            // код после break (не выполнится при срабатывании break)
 *        }
 *        
 *        // выполнение продолжается здесь после break
 *
 * ============================================================================
 */


#include <stdio.h>

// Условие: Получить восьмерично-кодированное десятичное представление

/*
 * Программа преобразует десятичные числа в их "восьмерично-десятичное" представление.
 * Каждая цифра десятичного числа преобразуется в восьмеричную систему,
 * но формат вывода сохраняет позиционную структуру исходного числа.
 *
 * Формат вывода:
 * - Каждая цифра исходного числа преобразуется в восьмеричную систему
 * - Если результат преобразования < 8, выводится с ведущим нулем (например, 3 -> "03")
 * - Если результат >= 8, выводится как есть
 * - Сохраняется исходный порядок цифр и знак числа
 *
 * Примеры:
 * Ввод: 123
 * Вывод: 010203
 * Объяснение: 1(dec)=1(oct) -> "01", 2(dec)=2(oct) -> "02", 3(dec)=3(oct) -> "03"
 *
 * Ввод: 89
 * Вывод: 1011
 * Объяснение: 8(dec)=10(oct) -> "10", 9(dec)=11(oct) -> "11"
 */

int main(void) {
    int num;  // Текущее число из входного потока

    // Чтение чисел из стандартного ввода пока успешно прочитано одно число
    while (scanf("%d", &num) == 1) {
        // ОСОБЫЙ СЛУЧАЙ: число 0
        if (num == 0) {
            printf("0\n");  // Выводим просто 0
            continue;       // Переходим к следующему числу
        }

        // ОБРАБОТКА ОТРИЦАТЕЛЬНЫХ ЧИСЕЛ
        int negative = 0;  // Флаг отрицательности: 0 - положительное, 1 - отрицательное
        if (num < 0) {
            num = -num;      // Работаем с модулем числа
            negative = 1;    // Запоминаем, что число было отрицательным
        }

        // ШАГ 1: ОПРЕДЕЛЯЕМ КОЛИЧЕСТВО ЦИФР В ЧИСЛЕ
        int class = num;     // Вспомогательная переменная для определения разрядов
        int count = 1;       // Степень 10 для старшего разряда (10^(n - 1))
        
        // Находим 10^(n - 1), где n - количество цифр
        // Пример: для 123: class = 123, count = 1 → class = 12, count = 10 → class = 1, count = 100 → class < 10 → stop
        while (class >= 10) {
            count *= 10;     // Увеличиваем множитель
            class /= 10;     // Уменьшаем число
        }
        // После цикла: count содержит 10^(n-1)

        // ШАГ 2: ВЫВОД ЗНАКА (если число было отрицательным)
        if (negative == 1) {
            printf("-");     // Выводим минус
            negative = 0;    // Сбрасываем флаг (больше не нужен)
        }

        // ШАГ 3: ПРЕОБРАЗОВАНИЕ И ВЫВОД КАЖДОЙ ЦИФРЫ
        class = count;  // Используем class как текущий множитель для выделения цифр
        
        // Идем от старшего разряда к младшему
        while (class > 0) {
            // Выделяем текущую цифру
            // Пример для 123 при class = 100: (123 / 100) % 10 = 1 % 10 = 1
            int digit = (num / class) % 10;
            
            // ПРЕОБРАЗОВАНИЕ ЦИФРЫ В ВОСЬМЕРИЧНУЮ СИСТЕМУ
            if (digit < 8) {
                // Цифра от 0 до 7: в восьмеричной системе такая же
                // Выводим с ведущим нулем для сохранения формата
                printf("0%d", digit);
            } else {
                // Цифра 8 или 9: нужно перевести в восьмеричную систему
                // Пример: digit = 8 → result = 10(oct), digit = 9 → result = 11(oct)
                int result = 0;      // Результат в восьмеричной системе
                int multiplier = 1;  // Множитель для сборки числа
                
                // Алгоритм перевода из десятичной в восьмеричную
                while (digit > 0) {
                    result += (digit % 8) * multiplier;  // Добавляем остаток
                    multiplier *= 10;  // Увеличиваем разряд
                    digit /= 8;        // Переходим к следующему разряду
                }
                // Выводим результат (без ведущих нулей)
                printf("%d", result);
            }
            
            // Переходим к следующему разряду
            class /= 10;
        }
        
        // Завершаем вывод числа переводом строки
        printf("\n");
    }
    
    return 0;
}
